# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:32:42+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import (
    AnyUrl,
    BaseModel,
    ConfigDict,
    Field,
    RootModel,
    confloat,
    conint,
    constr,
)


class Type(Enum):
    UserAccount = 'UserAccount'
    UserProfile = 'UserProfile'


class AccessToken(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountCreated: Optional[bool] = Field(
        None,
        description="When a `UserAccount` token is issued during a single-sign-on flow\na user may have been automatically registered if they didn't\nhave an account already. If this occurs then `accountCreated`\nwill be `true`.\n",
    )
    expirationDate: datetime = Field(
        ..., description='The timestamp this token expires.'
    )
    refreshable: bool = Field(
        ..., description='True if this token can be refreshed, false if not.'
    )
    type: Type = Field(..., description='The type of the token.')
    value: str = Field(
        ..., description='The token value used for authenticated requests.'
    )


class AccountNonce(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    value: str = Field(..., description='The nonce value.')


class Scope(Enum):
    Catalog = 'Catalog'
    Commerce = 'Commerce'
    Settings = 'Settings'
    Playback = 'Playback'


class AccountTokenByCodeRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: str = Field(..., description='The generated device authorization code.')
    id: str = Field(
        ..., description='The unique identifier for the device e.g. serial number.'
    )
    scopes: List[Scope] = Field(
        ..., description='The scope(s) of the token(s) required.'
    )


class CookieType(Enum):
    Session = 'Session'
    Persistent = 'Persistent'


class AccountTokenRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cookieType: Optional[CookieType] = Field(
        None,
        description="If you specify a cookie type then a content filter cookie will be returned\nalong with the token(s). This is only intended for web based clients which\nneed to pass the cookies to a server to render a page based on the user's\ncontent filters e.g subscription code.\n\nIf type `Session` the cookie will be session based.\nIf type `Persistent` the cookie will have a medium term lifespan.\nIf undefined no cookies will be set.\n",
    )
    email: str = Field(..., description='The email associated with the account.')
    password: str = Field(..., description='The password associated with the account.')
    scopes: List[Scope] = Field(
        ...,
        description='The scope(s) of the tokens required.\nFor each scope listed an Account and Profile token of that scope will be returned\n',
    )


class Type1(Enum):
    Card = 'Card'


class AddPaymentMethodRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    makeDefault: Optional[bool] = Field(
        None,
        description='Whether this payment method should become the account default when \nmaking purchases.\n\nNote that if this is the first payment method of type Card being added to an\naccount then it will become the default whether this property is true or false.\n',
    )
    token: str = Field(
        ...,
        description='The payment provider token representing a payment method, obtained by\nsubmitting payment method details to your third party provider.\n',
    )
    type: Type1 = Field(..., description='The type of payment method.')


class Address(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    addressLine1: Optional[str] = Field(
        None, description='The first line of the street address.'
    )
    addressLine2: Optional[str] = Field(
        None, description='The second line of the street address.'
    )
    city: Optional[str] = Field(None, description='The city name.')
    country: Optional[str] = Field(None, description='The country name or code.')
    postcode: Optional[str] = Field(None, description='The postal or zip code.')
    state: Optional[str] = Field(None, description='The state name or abbreviation.')


class AppConfigGeneral(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    currencyCode: Optional[str] = Field(
        None, description='The currency code to target.'
    )
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom configuration fields.'
    )
    defaultTimeZone: Optional[str] = Field(
        None, description='The default time zone of the site. e.g. "Etc/GMT"'
    )
    facebookAppId: Optional[str] = Field(
        None, description='The Facebook application id associated with an environment.'
    )
    gaToken: Optional[str] = Field(
        None, description='A Google Analytics token to track applicaton user events.'
    )
    itemImageTypes: Optional[Dict[str, str]] = Field(
        None,
        description='A map of default item image types where the key is the item types.',
    )
    mandatorySignIn: Optional[bool] = Field(
        None, description='Whether to require sign in for customers to access content.'
    )
    maxUserRating: Optional[int] = Field(
        None, description='The maximum value allowed for user ratings.'
    )
    stripeKey: Optional[str] = Field(
        None, description='The public Stripe key to use for payment transactions.'
    )
    websiteUrl: Optional[AnyUrl] = Field(
        None, description='The url of the primary website.'
    )


class AppConfigLinear(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    scheduleCacheMaxAgeMinutes: Optional[int] = Field(
        None, description='The maximum minutes of schedule cache time.'
    )
    viewingWindowDaysAfter: Optional[int] = Field(
        None, description='Number of available upcoming day schedules.'
    )
    viewingWindowDaysBefore: Optional[int] = Field(
        None, description='Number of available day schedules in the past.'
    )


class AppConfigPlayback(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    chainPlayCountdown: int = Field(
        ...,
        description='The number of seconds before autoplay of next video.\n\nIf set to 0 there will be no autoplay.\n',
    )
    chainPlaySqueezeback: int = Field(
        ...,
        description='The number of seconds before the end of playback when the current video\nshould be minimized and user options are presented within the video player.\n\nIf set to 0 there will be no squeezeback.\n',
    )
    chainPlayTimeout: int = Field(
        ...,
        description='The number of minutes of user inactivity before autoplay is paused.\n\nIf set to 0 there will be no autoplay timeout.\n',
    )
    heartbeatFrequency: int = Field(
        ..., description='How often a heartbeat should be renewed during playback.'
    )
    viewEventPoints: List[confloat(ge=0.0, le=1.0)] = Field(
        ...,
        description='An array of percentage points in which to fire off plabyack view events.\nFor example a value of 0.5 would indicate that an event should be\nfired when the user is half way through the video.\nOften known as quartiles when four equaly spread event points.\n',
    )


class Bookmark(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    creationDate: datetime = Field(
        ..., description='The date the bookmark was created.'
    )
    itemId: str = Field(..., description='The id of the item bookmarked.')


class Interval(Enum):
    day = 'day'
    week = 'week'
    month = 'month'
    year = 'year'
    none = 'none'


class BtPlanListItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: Optional[float] = Field(
        None, description='The price of a plan. If a free plan then undefined.'
    )
    ctaText: str = Field(..., description='The textual description.')
    currency: str = Field(..., description='The currency a plan is offered in.')
    description: str = Field(..., description='The textual description.')
    ees07PlanDescription: Optional[str] = None
    ees07PlanTitle: Optional[str] = None
    ees07Title: Optional[str] = None
    headerText: str = Field(..., description='The textual description.')
    heroText: str = Field(..., description='The textual description.')
    id: str = Field(..., description='The identifier of a plan.')
    interval: Optional[Interval] = Field(
        None, description='The type of billing period used.'
    )
    intervalCount: Optional[int] = Field(
        None,
        description='Given the `interval` this is how frequently it will run. e.g. every 2 weeks.',
    )
    longText: str = Field(..., description='The textual description.')
    nickname: str = Field(..., description='The title of a plan.')
    noThanksText: Optional[str] = None
    product: str = Field(..., description='The product of a plan.')
    switchingText: Optional[str] = None
    termsAndConditionsItunes: Optional[str] = None
    termsAndConditionsStripe: Optional[str] = None
    trialPeriodDays: int = Field(
        ...,
        description='How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.',
    )


class BtPlans(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plans: List[BtPlanListItem] = Field(..., description='The list of available plans.')


class BtValidateTokenResponse(BaseModel):
    pass


class ChangePasswordRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    password: str = Field(..., description='The new password for the account.')
    profileToken: str = Field(..., description='The ITV profile token.')


class ChangePinRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    pin: str = Field(..., description='The new pin to set.')


class ClassificationSummary(BaseModel):
    code: str = Field(..., description='The unique code for a classification.')
    name: str = Field(..., description='The name of the classification for display.')


class Role(Enum):
    actor = 'actor'
    associateproducer = 'associateproducer'
    coactor = 'coactor'
    director = 'director'
    executiveproducer = 'executiveproducer'
    filminglocation = 'filminglocation'
    guest = 'guest'
    narrator = 'narrator'
    other = 'other'
    presenter = 'presenter'
    producer = 'producer'
    productmanager = 'productmanager'
    thememusicby = 'thememusicby'
    voice = 'voice'
    writer = 'writer'


class Device(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(
        ..., description='The unique identifier for this device e.g. serial number.'
    )
    name: str = Field(..., description='The human recognisable name for this device.')
    registrationDate: datetime = Field(
        ..., description='The date this device was registered.'
    )
    type: str = Field(..., description='The device type e.g. web_browser.')


class DeviceAuthorizationCode(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: str = Field(..., description='The generated device authorization code.')


class DeviceRegistrationRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(
        ..., description='The unique identifier for this device e.g. serial number.'
    )
    name: str = Field(..., description='A human recognisable name for this device.')
    type: str = Field(..., description='The device type e.g. web_browser.')


class DeviceRegistrationWindow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    endDate: datetime = Field(
        ...,
        description='The end date of the current period.\n\nThis is based on the value of `startDate` plus the number of days defined by  `periodDays`.\n',
    )
    limit: int = Field(
        ..., description='The maximum de/registrations that can be made in a period.'
    )
    periodDays: int = Field(
        ..., description='The number of days a de/registration period runs for.'
    )
    remaining: int = Field(
        ...,
        description='The remaining de/registrations that can be made in the current period.',
    )
    startDate: datetime = Field(
        ...,
        description='The start date of the current period.\n\nThis is based on the earliest device de/registrations in the past N days, where\nN is defined by `periodDays`.\n\nIf no device has been de/registered then start date will be from the current date.\n',
    )


class EeBtEligibility(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    eligible: bool = Field(..., description='Whether or not user is eligible')
    plan: Optional[str] = Field(None, description='The identifier of a plan.')
    source: Optional[str] = Field(None, description='Stripe etc.')


class EeCreatePinRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str = Field(
        ...,
        description='EE API authorization Token received from GET /ee/token/create.',
    )
    msisdn: str = Field(..., description='The msisdn.')
    trackingHeader: Optional[str] = Field(None, description='trackingHeader')


class EeCreatePinResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    pinReference: str = Field(..., description='The pinReference.')
    trackingHeader: str = Field(..., description='trackingHeader')


class EeCreateTokenResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: Optional[str] = Field(
        None, description='The authentication token for later use to call EE endpoints.'
    )
    expiresIn: Optional[float] = None
    tokenType: Optional[str] = None


class EeIdentityRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str = Field(
        ...,
        description='EE API authorization Token received from GET /ee/token/create.',
    )
    sessionId: str = Field(
        ..., description='The sessionId returned in the ee/session response.'
    )


class EeIdentityResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    brand: Optional[str] = Field(None, description='The operator brand.')
    brandCode: Optional[str] = Field(None, description='The brand code.')
    msisdn: str = Field(..., description='The msisdn.')
    trackingHeader: str = Field(..., description='trackingHeader')


class EeOfferItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='The identifier of an offer.')


class EeOffersRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str = Field(
        ...,
        description='EE API authorization Token received from GET /ee/token/create.',
    )
    msisdn: str = Field(..., description='The msisdn.')
    trackingHeader: Optional[str] = Field(None, description='trackingHeader.')


class EeOffersResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    eligibleOffers: List[EeOfferItem] = Field(
        ..., description='The list of eligible offers.'
    )


class EePlanListItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: Optional[float] = Field(
        None, description='The price of a plan. If a free plan then undefined.'
    )
    ctaText: str = Field(..., description='The textual description.')
    currency: str = Field(..., description='The currency a plan is offered in.')
    description: str = Field(..., description='The textual description.')
    headerText: str = Field(..., description='The textual description.')
    heroText: str = Field(..., description='The textual description.')
    id: str = Field(..., description='The identifier of a plan.')
    interval: Optional[Interval] = Field(
        None, description='The type of billing period used.'
    )
    intervalCount: Optional[int] = Field(
        None,
        description='Given the `interval` this is how frequently it will run. e.g. every 2 weeks.',
    )
    longText: str = Field(..., description='The textual description.')
    nickname: str = Field(..., description='The title of a plan.')
    product: str = Field(..., description='The product of a plan.')
    trialPeriodDays: int = Field(
        ...,
        description='How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.',
    )


class EePlans(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plans: List[EePlanListItem] = Field(..., description='The list of available plans.')


class EeSessionIdRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str = Field(
        ...,
        description='EE API authorization Token received from GET /ee/token/create.',
    )
    clientIP: str = Field(..., description='The IP address of the requesting device.')


class EeSessionIdResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    sessionId: str = Field(..., description='The assigned SessionId.')


class EeValidatePinRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str = Field(
        ...,
        description='EE API authorization Token received from GET /ee/token/create.',
    )
    pin: str = Field(..., description='The pin entered by a user. 6 digits')
    pinReference: str = Field(..., description='The pinReference.')
    trackingHeader: Optional[str] = Field(
        None,
        description='Tracking header to be able to search logs for a specific user requests. If not provided it will be generated. FE should store it for later user.',
    )


class EeValidatePinResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    pinValid: Optional[str] = Field(None, description='The validation status.')
    trackingHeader: str = Field(..., description='trackingHeader')


class ItemType(Enum):
    movie = 'movie'
    show = 'show'
    season = 'season'
    episode = 'episode'
    program = 'program'
    link = 'link'
    trailer = 'trailer'
    channel = 'channel'
    customAsset = 'customAsset'


class ExcludeDelivery(Enum):
    Stream = 'Stream'
    Download = 'Download'
    StreamOrDownload = 'StreamOrDownload'
    ProgressiveDownload = 'ProgressiveDownload'
    None_ = 'None'


class ExcludeMinResolution(Enum):
    SD = 'SD'
    HD_720 = 'HD-720'
    HD_1080 = 'HD-1080'
    HD_4K = 'HD-4K'
    External = 'External'
    Unknown = 'Unknown'


class ExclusionRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = None
    device: Optional[str] = Field(
        None, description='The device type that the exclusion rules apply to.'
    )
    excludeAirplay: Optional[bool] = Field(
        None, description='Prevent airplay from an apple device.'
    )
    excludeChromecast: Optional[bool] = Field(
        None, description='Prevent chromecasting.'
    )
    excludeDelivery: Optional[ExcludeDelivery] = None
    excludeMinResolution: Optional[ExcludeMinResolution] = None


class DeliveryType(Enum):
    Stream = 'Stream'
    Progressive = 'Progressive'
    Download = 'Download'


class Resolution(Enum):
    SD = 'SD'
    HD_720 = 'HD-720'
    HD_1080 = 'HD-1080'
    HD_4K = 'HD-4K'
    External = 'External'
    Unknown = 'Unknown'


class ItemClipFile(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    channels: Optional[int] = Field(None, description='The number of audio channels.')
    deliveryType: DeliveryType = Field(
        ..., description='The way in which the media file is delivered.'
    )
    drm: str = Field(
        ...,
        description="The type of drm used to encrypt the media. 'None' if unencrypted.",
    )
    format: str = Field(..., description='The format the media was encoded in.')
    height: int = Field(..., description='The height of the video media.')
    language: str = Field(
        ..., description="The language code for the media, e.g. 'en'."
    )
    name: str = Field(..., description='The name of the media file.')
    resolution: Resolution = Field(
        ..., description='The resolution of the video media.'
    )
    url: AnyUrl = Field(..., description='The url to access the media file.')
    width: int = Field(..., description='The width of the video media.')


class ItemClipFiles(BaseModel):
    clips: List[ItemClipFile] = Field(..., description='Array of item clip file.')
    id: str = Field(..., description='Unique identifier for an Item')


class ItemClipFilesList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    items: List[ItemClipFiles] = Field(..., description='A list of items')


class ItemCustomMetadata(BaseModel):
    name: str = Field(..., description='The name of the custom metadata.')
    value: str = Field(..., description='The value of the custom metadata.')


class ItemDownloadable(BaseModel):
    downloadable: bool = Field(..., description='is the item downloadable?')
    id: str = Field(..., description='Unique identifier for an Item')


class ItemDownloadableList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    items: List[ItemDownloadable] = Field(..., description='A list of items')


class ItemDownloadableRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ids: str = Field(..., description='Comma-separated list of AXIS item ids.')


class Ownership(Enum):
    Subscription = 'Subscription'
    Free = 'Free'
    Rent = 'Rent'
    Own = 'Own'
    None_ = 'None'


class Type2(Enum):
    movie = 'movie'
    show = 'show'
    season = 'season'
    episode = 'episode'
    program = 'program'
    link = 'link'
    trailer = 'trailer'
    channel = 'channel'
    customAsset = 'customAsset'


class ItemPurchase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The identifier of the purchased item.')
    ownership: Ownership = Field(
        ..., description='The ownership of the purchased item.'
    )
    resolution: Resolution = Field(
        ..., description='The resolution of the purchased item.'
    )
    title: str = Field(..., description='The title of the purchased item.')
    type: Type2 = Field(..., description='The type of item purchased.')


class ItemSchedule(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    blackout: Optional[bool] = Field(
        None,
        description='True if this schedule represents time when the channel is completely off air.',
    )
    channelId: str = Field(
        ..., description='The id of the channel item this schedule belongs to.'
    )
    endDate: datetime = Field(..., description='The date and time this schedule ends.')
    featured: Optional[bool] = Field(
        None, description='True if this is a featured item schedule.'
    )
    id: str
    live: Optional[bool] = Field(None, description='True if this is a live event.')
    repeat: Optional[bool] = Field(
        None, description='True if this has been aired previously on the same channel.'
    )
    startDate: datetime = Field(
        ..., description='The date and time this schedule starts.'
    )


class ItemScheduleList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    channelId: str = Field(
        ..., description='The id of the channel the schedules belong to.'
    )
    endDate: datetime = Field(
        ..., description='The date and time this list of schedules ends.'
    )
    schedules: List[ItemSchedule] = Field(
        ..., description='The list of item schedules.'
    )
    startDate: datetime = Field(
        ..., description='The date and time this list of schedules starts.'
    )


class ItvAssignBtTokenRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token')
    token: str = Field(..., description='The validated userToken.')


class ItvAssignMsisdnRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    eeProductId: str = Field(..., description='Product id from /ee/offers')
    msisdn: str = Field(..., description='The validated msisdn.')
    profileToken: str = Field(..., description='The ITV profile token')
    trackingHeader: str = Field(..., description='trackingHeader')


class ItvBillingHistoryRecord(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    card: Dict[str, Any] = Field(..., description='The card info.')
    charge: Dict[str, Any] = Field(..., description='The amount charged.')
    invoice: Dict[str, Any] = Field(..., description='The object with invoice details.')
    subscription: Dict[str, Any] = Field(
        ..., description='The object with subscription payment details.'
    )


class ItvBillingHistoryRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvCancelSubscriptionRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvCardDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    card_type: str = Field(
        ..., description='The payment card type (Visa/Mastercard/etc).'
    )
    exp_month: int = Field(..., description='Expiry date month.')
    exp_year: int = Field(..., description='Expiry date year.')
    last4: str = Field(..., description='The last 4 digit of card number.')


class ItvChangeCardDetailsRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cardToken: str = Field(..., description='The credit card token.')
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvChangeEmailRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: str = Field(..., description='New email address for account/profile.')
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvChangeMarketingRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    emailOptIn: bool = Field(
        ..., description='Updated marketing preferences for account/profile.'
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvCurrentSubscription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cancelAtPeriodEnd: bool = Field(
        ..., description='The cancellation period end flag.'
    )
    collectionMethod: str = Field(
        ..., description='The description of payment collection method.'
    )
    created: int = Field(..., description='The creation timestamp.')
    currentPeriodEnd: int = Field(..., description='The end of period timestamp.')
    currentPeriodStart: int = Field(..., description='The start of period timestamp.')
    plan: Dict[str, Any] = Field(..., description='The plan used during subsribing.')
    status: str = Field(..., description='The status of subscription.')


class ItvDeleteAccountRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvEntitlement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    card_type: Optional[datetime] = Field(None, description='Start of subscription.')
    expiry: datetime = Field(..., description='Expiry of subscription.')
    plan: Dict[str, Any] = Field(..., description='Purchased plan data.')
    source: str = Field(..., description='Source platform of purchase.')
    subscriptionId: str = Field(..., description='Id of subscription.')


class ItvEntitlementCancelation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cancelled_at: datetime = Field(..., description='Cancelation datetime.')
    itvId: str = Field(..., description='Itv internal id.')
    source: str = Field(..., description='Source platform of cancelation.')
    subscriptionId: str = Field(..., description='Id of subscription.')


class ItvEntitlementCurrent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    source: str = Field(
        ..., description='one of “itunes”, “stripe”, “amazon”, “google”'
    )


class ItvEntitlementPlan(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cost: int = Field(..., description='Source platform of purchase.')
    interval: Interval = Field(..., description='The type of billing period used.')
    trialLength: int = Field(
        ...,
        description='Given the `interval` this is how frequently it will run. e.g. every 2 weeks.',
    )
    type: str = Field(..., description='Type of the plan.')


class ItvEntitlementsHistory(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cancellations: List[ItvEntitlementCancelation] = Field(
        ..., description='The results of availability checks.'
    )
    entitlements: List[ItvEntitlement] = Field(
        ..., description='The results of availability checks.'
    )


class ItvFeatureFlag(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: bool = Field(..., description='Is the feature enabled?')
    flag: Optional[str] = Field(None, description='Feature flag data.')


class ItvGetCardDetailsRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvGetDiscountResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    currency: Optional[str] = Field(None, description='Payment currency.')
    description: Optional[str] = Field(None, description='Description')
    headline: Optional[str] = Field(None, description='Headline')
    id: str = Field(..., description='The if of a discount for a user.')
    initialCost: Optional[float] = Field(None, description='The initial cost.')
    longDescription: Optional[str] = Field(None, description='Long description')
    nickname: Optional[str] = Field(None, description='Discount nickname.')
    offerdurationperiod: Optional[str] = Field(
        None, description='How long the descount will be valid for.'
    )
    shortDescription: Optional[str] = Field(None, description='Short description')


class ItvGooglePaySubscriptionRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    purchaseToken: str = Field(
        ..., description='the unique identifier for this purchase'
    )
    subscriptionItem: str = Field(
        ..., description='the SKU of the item from the play console'
    )


class ItvHadEntitlement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hasHadEntitlements: bool = Field(
        ..., description='whether the user has been previously entitlement'
    )


class ItvPinAuthRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cookieType: Optional[CookieType] = Field(
        None,
        description="If you specify a cookie type then a content filter cookie will be returned\nalong with the token(s). This is only intended for web based clients which\nneed to pass the cookies to a server to render a page based on the user's\ncontent filters e.g subscription code.\n\nIf type `Session` the cookie will be session based.\nIf type `Persistent` the cookie will have a medium term lifespan.\nIf undefined no cookies will be set.\n",
    )
    pin: str = Field(..., description='The 4-digit parental control pin.')
    scopes: Optional[List[Scope]] = Field(
        None, description='The scope(s) of the token(s) required.'
    )


class ItvPlanListItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: float = Field(
        ..., description='The price of a plan. If a free plan then undefined.'
    )
    currency: str = Field(..., description='The currency a plan is offered in.')
    description: str = Field(..., description='The textual description.')
    id: str = Field(..., description='The identifier of a plan.')
    interval: Interval = Field(..., description='The type of billing period used.')
    intervalCount: int = Field(
        ...,
        description='Given the `interval` this is how frequently it will run. e.g. every 2 weeks.',
    )
    nickname: str = Field(..., description='The title of a plan.')
    product: str = Field(..., description='The product description.')
    savingLabel: Optional[str] = Field(None, description='The saving label.')
    switchingText: Optional[str] = Field(None, description='The text to switch for.')
    trialPeriodDays: Optional[int] = Field(
        None,
        description='How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.',
    )


class ItvPlans(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plans: List[ItvPlanListItem] = Field(
        ..., description='The list of available plans.'
    )


class ItvProfileToken(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvProfileTokenRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    password: str = Field(..., description='The password.')


class ItvPurchase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customerId: Optional[str] = Field(
        None, description='The identifier of user in payment system.'
    )
    planId: str = Field(..., description='The identifier of subscription plan.')
    subscriptionId: Optional[str] = Field(
        None, description='The identifier of subscription in payment system.'
    )


class ItvPurchaseRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cardToken: str = Field(..., description='The credit card token.')
    planId: str = Field(..., description='The identifier of the plan to purchase.')
    profileToken: str = Field(..., description='The ITV profile token.')
    voucher: Optional[str] = Field(None, description='A coupon/voucher for a discount.')


class ItvPurchaseStrongRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    paymentMethodFromToken: Optional[str] = Field(
        None, description='A paymentMethodFromToken.'
    )
    paymentMethodId: Optional[str] = Field(
        None, description='A paymentMethodId from Stripe.'
    )
    planId: str = Field(..., description='The identifier of the plan to purchase.')
    profileToken: str = Field(..., description='The ITV profile token.')
    voucher: Optional[str] = Field(None, description='A coupon/voucher for a discount.')


class ItvPurchaseStrongResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    clientSecret: Optional[str] = Field(None, description='clientSecret.')
    customerId: Optional[str] = Field(
        None, description='The identifier of user in payment system.'
    )
    intentId: Optional[str] = Field(None, description='IntentId.')
    intentType: Optional[str] = Field(None, description='intentType.')
    planId: Optional[str] = Field(
        None, description='The identifier of subscription plan.'
    )
    status: Optional[str] = Field(None, description='Status.')
    subscriptionId: Optional[str] = Field(
        None, description='The identifier of subscription in payment system.'
    )


class ItvPurchaseWithOfferRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    couponId: str = Field(
        ...,
        description='A coupon/voucher for a discount. Can be retrieved from GET itv/voucher/{platform} endpoint',
    )
    paymentMethodFromToken: Optional[str] = Field(
        None, description='A paymentMethodFromToken.'
    )
    paymentMethodId: Optional[str] = Field(
        None, description='A paymentMethodId from Stripe.'
    )
    planId: str = Field(..., description='The identifier of the plan to purchase.')
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvPurchaseWithOfferResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    clientSecret: Optional[str] = Field(None, description='clientSecret.')
    customerId: Optional[str] = Field(
        None, description='The identifier of user in payment system.'
    )
    intentId: Optional[str] = Field(None, description='IntentId.')
    intentType: Optional[str] = Field(None, description='intentType.')
    paymentMethodId: Optional[str] = Field(None, description='Payment Method ID')
    status: Optional[str] = Field(None, description='Status.')
    subscriptionId: Optional[str] = Field(
        None, description='The identifier of subscription in payment system.'
    )


class ItvRokuTransactionRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvSubscriptionFullPriceRenewal(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fullPriceRenewal: bool = Field(..., description='full price renewal state.')
    reason: str = Field(..., description='reason of full price renewal state.')


class ItvSubscriptionState(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    effective_entitlements: List[ItvEntitlement] = Field(
        ..., description='The array of entitlement objects.'
    )
    failed_availability_checks: List[str] = Field(
        ..., description='The results of availability checks.'
    )
    purchased: List[str] = Field(..., description='The array of entitlement names.')
    source: str = Field(..., description='The payment provider (stripe/itunes)')


class ItvSubscriptionStatusResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    is_active: bool = Field(
        ..., description='Defines whether last payment intent was successful or not.'
    )


class ItvUpdateIntentStrongRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    paymentMethodFromToken: Optional[str] = Field(
        None, description='A paymentMethodFromToken.'
    )
    paymentMethodId: Optional[str] = Field(
        None, description='The paymentMethodId from Stripe.'
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvUpdateIntentStrongResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    clientSecret: Optional[str] = Field(None, description='ClientSecret.')
    intentId: Optional[str] = Field(None, description='IntentId.')
    intentType: Optional[str] = Field(None, description='IntentType.')
    status: Optional[str] = Field(None, description='Status.')


class ItvUpdatePaymentStrongRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    paymentMethodFromToken: Optional[str] = Field(
        None, description='A paymentMethodFromToken.'
    )
    paymentMethodId: Optional[str] = Field(
        None, description='The paymentMethodId from Stripe.'
    )
    profileToken: str = Field(..., description='The ITV profile token.')


class ItvUpdateProfileRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    dateOfBirth: Optional[str] = Field(None, description='The date of birth.')
    email: Optional[str] = Field(None, description='The email address.')
    firstName: Optional[str] = Field(None, description='Last name.')
    lastName: Optional[str] = Field(None, description='First name.')
    postcode: Optional[str] = Field(None, description='The postal code.')
    profileToken: str = Field(..., description='The ITV profile token.')
    title: Optional[str] = Field(None, description='The title.')


class ItvUpgradePlanRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    planId: str = Field(..., description='The identifier of the plan to purchase.')


class OfferType(Enum):
    stripe = 'stripe'
    talon_one = 'talon one'


class ItvVoucherDisplay(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    currency: Optional[str] = Field(None, description='Currency.')
    discountPrice: Optional[str] = Field(None, description='Discount price.')
    duration: Optional[str] = Field(None, description='Duration.')
    durationInMonths: Optional[float] = Field(None, description='Duration in months.')
    headlineLabel: Optional[str] = Field(None, description='Headline label.')
    initialCost: Optional[float] = Field(None, description='InitialCost.')
    longDescription: Optional[str] = Field(None, description='Long description.')
    percentOff: Optional[float] = Field(None, description='Percent off.')
    savingLabel: Optional[str] = Field(None, description='SavingLabel.')
    shortDescription: Optional[str] = Field(None, description='Short description.')


class ItvVoucherLinksHref(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    href: str = Field(..., description='The voucher link.')


class ItvVoucherRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    voucher: str = Field(..., description='The voucher.')


class Language(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: str = Field(
        ...,
        description='The ISO language code of the language e.g. "en-US".\nSee https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n',
    )
    label: str = Field(..., description='Display label for the language.')
    title: str = Field(..., description='Display title for the language.')


class MediaFile(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    channels: Optional[int] = Field(None, description='The number of audio channels.')
    deliveryType: DeliveryType = Field(
        ..., description='The way in which the media file is delivered.'
    )
    drm: str = Field(
        ...,
        description="The type of drm used to encrypt the media. 'None' if unencrypted.",
    )
    format: str = Field(..., description='The format the media was encoded in.')
    height: int = Field(..., description='The height of the video media.')
    language: str = Field(
        ..., description="The language code for the media, e.g. 'en'."
    )
    name: str = Field(..., description='The name of the media file.')
    resolution: Resolution = Field(
        ..., description='The resolution of the video media.'
    )
    url: AnyUrl = Field(..., description='The url to access the media file.')
    width: int = Field(..., description='The width of the video media.')


class SuggestionType(Enum):
    StartWatching = 'StartWatching'
    ContinueWatching = 'ContinueWatching'
    RestartWatching = 'RestartWatching'
    Sequential = 'Sequential'
    None_ = 'None'


class Availability(Enum):
    Available = 'Available'
    ComingSoon = 'ComingSoon'


class DeliveryType2(Enum):
    Stream = 'Stream'
    Download = 'Download'
    StreamOrDownload = 'StreamOrDownload'
    ProgressiveDownload = 'ProgressiveDownload'
    None_ = 'None'


class OfferRights(BaseModel):
    deliveryType: DeliveryType2
    exclusionRules: Optional[List[ExclusionRule]] = Field(
        None, description='Any specific playback exclusion rules.'
    )
    maxDownloads: Optional[int] = Field(
        None, description='The maximum number of allowed downloads.'
    )
    maxPlays: Optional[int] = Field(
        None, description='The maximum number of allowed plays.'
    )
    ownership: Ownership
    playPeriod: Optional[int] = Field(
        None,
        description='The length of time in minutes which the rental will last once played for the first time.',
    )
    rentalPeriod: Optional[int] = Field(
        None,
        description='The length of time in minutes which the rental will last once purchased.',
    )
    resolution: Resolution
    scopes: List[str]


class Type4(Enum):
    ItemEntry = 'ItemEntry'
    ItemDetailEntry = 'ItemDetailEntry'
    ListEntry = 'ListEntry'
    ListDetailEntry = 'ListDetailEntry'
    UserEntry = 'UserEntry'
    TextEntry = 'TextEntry'
    ImageEntry = 'ImageEntry'
    CustomEntry = 'CustomEntry'
    PeopleEntry = 'PeopleEntry'


class PageMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = None
    keywords: Optional[List[str]] = None
    segments: Optional[List[str]] = None


class PageSummary(BaseModel):
    id: str = Field(..., description='Unique identifier for the page.')
    isStatic: bool = Field(
        ...,
        description="True if this page is static and doesn't have any dynamic content to load.\n\nStatic pages don't need to go back to the page endpoint to load page content\ninstead the page summary loaded with the sitemap should be enough to determine\nthe page template type and render based on this.\n",
    )
    isSystemPage: bool = Field(
        ...,
        description="True if this page is a system page type.\n\n**DEPRECATED** This property doesn't have any real use in client applications\nanymore so shouldn't be used. It especially shouldn't be used to determine if\na page is static or not. Use the `isStatic` property instead.\n",
    )
    key: Optional[str] = Field(None, description='Key used to lookup a known page.')
    path: str = Field(..., description='Unique path for the page.')
    template: str = Field(
        ..., description='Identifier for of the page template to render this page.'
    )
    title: str = Field(..., description='Title of the page.')


class Scope3(Enum):
    Catalog = 'Catalog'
    Commerce = 'Commerce'
    Settings = 'Settings'


class Type5(Enum):
    UserAccount = 'UserAccount'
    UserProfile = 'UserProfile'


class PaginationAuth(BaseModel):
    scope: Scope3 = Field(..., description='The token scope required.')
    type: Type5 = Field(..., description='The token type required to load the list.')


class Order(Enum):
    asc = 'asc'
    desc = 'desc'


class OrderBy(Enum):
    a_z = 'a-z'
    release_year = 'release-year'
    date_added = 'date-added'


class PaginationOptions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    completed: Optional[bool] = Field(
        None,
        description="Items filtered by whether they've been fully watched or not.\n\nOnly available on the `/account/profile/watched/list` endpoint currently.\n",
    )
    itemType: Optional[ItemType] = Field(None, description='Specific item type filter.')
    maxRating: Optional[str] = Field(
        None,
        description="The maximum rating (inclusive) of items returned, e.g. 'AUOFLC-PG'.",
    )
    order: Optional[Order] = Field(None, description='The applied sort order if any.')
    orderBy: Optional[OrderBy] = Field(
        None, description='The applied sort ordering property if any.'
    )
    pageSize: Optional[int] = Field(
        None, description='The number of items to return in a list page.'
    )


class PasswordResetEmailRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: str = Field(
        ...,
        description='The email address of the primary account profile to reset the password for.',
    )


class PasswordResetRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    password: str = Field(..., description='The new password for the account.')
    resetToken: str = Field(..., description='The ITV reset token.')


class Brand(Enum):
    Visa = 'Visa'
    MasterCard = 'MasterCard'
    AmericanExpress = 'AmericanExpress'
    Other = 'Other'


class Type6(Enum):
    Card = 'Card'
    Wallet = 'Wallet'


class PaymentMethod(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    balance: Optional[float] = Field(
        None, description='The balance of the wallet if the payment method is a wallet.'
    )
    brand: Optional[Brand] = Field(
        None, description='The brand of the card if the payment method is a card.'
    )
    currency: Optional[str] = Field(
        None,
        description='The currency code of the wallet if the payment method is a wallet.',
    )
    description: str = Field(
        ...,
        description='A short description of a payment method.\n\nIf the payment method is of type `Wallet` this will be "My Wallet"\n\nFor `Card` type payment methods the format of this description may differ\ndepending on the payment gateway in use. In the case of Stripe, this will\nbe in the format "Visa (**** 4242, exp 08/19)"\n',
    )
    expiryMonth: Optional[float] = Field(
        None,
        description='The expiry month of the card if the payment method is a card.',
    )
    expiryYear: Optional[float] = Field(
        None, description='The expiry year of the card if the payment method is a card.'
    )
    id: str = Field(..., description='The unique identifier of a payment method.')
    lastDigits: Optional[float] = Field(
        None,
        description='The last digits of the card if the payment method is a card.\nDepending on the payment gateway in use this value may be undefined.\n',
    )
    type: Type6 = Field(..., description='The type of payment method.')


class Person(BaseModel):
    name: str = Field(..., description='The name of the person.')
    path: str = Field(..., description='The path to the person')


class BillingPeriodType(Enum):
    day = 'day'
    week = 'week'
    month = 'month'
    year = 'year'
    none = 'none'


class RevenueType(Enum):
    TVOD = 'TVOD'
    SVOD = 'SVOD'


class Type7(Enum):
    Free = 'Free'
    Subscription = 'Subscription'


class Plan(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    alias: str = Field(..., description='An alias for a plan.')
    benefits: List[str] = Field(
        ..., description='The list of benefits to display for a plan.'
    )
    billingPeriodFrequency: int = Field(
        ...,
        description='Given the `billingPeriodType` this is how frequently it will run. e.g. every 2 weeks.',
    )
    billingPeriodType: BillingPeriodType = Field(
        ..., description='The type of billing period used.'
    )
    currency: str = Field(..., description='The currency a plan is offered in.')
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for a plan.'
    )
    hasTrialPeriod: bool = Field(
        ..., description='True if a plan has a trial period, false if not.'
    )
    id: str = Field(..., description='The identifier of a plan.')
    isActive: bool = Field(
        ..., description='True if a plan is active, false if its retired.'
    )
    isFeatured: bool = Field(
        ...,
        description='True if a plan should be highlighted as featured, false if not.',
    )
    isPrivate: bool = Field(
        ...,
        description='True if a plan should not be presented in the primary plan options, false if not.',
    )
    price: Optional[float] = Field(
        None, description='The price of a plan. If a free plan then undefined.'
    )
    revenueType: RevenueType = Field(
        ..., description='The revenue type a plan targets.'
    )
    subscriptionCode: str = Field(
        ..., description='The subscription code a plan targets.'
    )
    tagline: str = Field(..., description='The short tagline for a plan.')
    termsAndConditions: str = Field(
        ..., description='The terms and conditions for a plan.'
    )
    title: str = Field(..., description='The title of a plan.')
    trialPeriodDays: int = Field(
        ...,
        description='How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.',
    )
    type: Type7 = Field(..., description='The type of plan.')


class PlanPurchase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The identifier of the purchased plan.')
    price: Optional[float] = Field(None, description='The price of the purchased plan.')
    subscriptionId: Optional[str] = Field(
        None, description='The identifier of the subscription membership to the plan.'
    )
    title: str = Field(..., description='The title of the purchased plan.')
    type: Type7 = Field(..., description='The type of plan purchased.')


class ProfileCreationRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    languageCode: Optional[str] = Field(
        None,
        description='The code of the preferred language for the profile.\nMust be a valid ISO language code e.g. "en-US" and must match the code of\none of the languages specified in the app config.\nSee https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n',
    )
    name: constr(min_length=1) = Field(
        ..., description='The unique name of the profile.'
    )
    pinEnabled: Optional[bool] = Field(
        False,
        description='Whether an account pin is required to enter the profile.\n\nIf no account pin is defined this has no impact.\n',
    )
    purchaseEnabled: Optional[bool] = Field(
        True,
        description='Whether the profile can make purchases with the account payment options.',
    )
    segments: Optional[List[str]] = Field(
        None, description='The segments a profile should be placed under'
    )


class ProfileSummary(BaseModel):
    color: Optional[str] = Field(
        None, description='Hex color value assigned to the profile.'
    )
    heroAutoplay: Optional[bool] = Field(
        None, description='Gets the Hero row clip auto playback enabled'
    )
    heroWithAudio: Optional[bool] = Field(
        None, description='Gets the Hero row clip auto playback audio enabled'
    )
    id: str = Field(..., description='The id of the profile.')
    isActive: bool = Field(
        ...,
        description='Whether the profile is active or not.\n\n**DEPRECATED** - Always true. Inactive profiles are no longer returned.\n',
    )
    languageCode: Optional[str] = Field(
        None,
        description='The code of the preferred language for the profile.\nMust be a valid ISO language code e.g. "en-US" and must match the code of\none of the languages specified in the app config.\nSee https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n',
    )
    marketingEnabled: bool = Field(
        ...,
        description='Whether the profile has opted in or out of marketing material.\n\n**DEPRECATED** - Marketing material is no longer tied to profiles, only account. See `Account.marketingEnabled`.\n',
    )
    maxRatingContentFilter: Optional[ClassificationSummary] = None
    minRatingPlaybackGuard: Optional[ClassificationSummary] = None
    name: str = Field(..., description='The unique name of the profile.')
    pinEnabled: bool = Field(
        ..., description='Whether a pin is required to enter the profile.'
    )
    purchaseEnabled: bool = Field(
        ...,
        description='Whether the profile can make purchases with the account payment options.',
    )
    segments: List[str] = Field(
        ..., description='The segments a profile has been placed under'
    )


class ProfileTokenRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cookieType: Optional[CookieType] = Field(
        None,
        description="If you specify a cookie type then a content filter cookie will be returned\nalong with the token(s). This is only intended for web based clients which\nneed to pass the cookies to a server to render a page based on the user's\ncontent filters e.g subscription code.\n\nIf type `Session` the cookie will be session based.\nIf type `Persistent` the cookie will have a medium term lifespan.\nIf undefined no cookies will be set.\n",
    )
    pin: Optional[str] = Field(
        None, description='The pin associated with this profile, if any.'
    )
    profileId: str = Field(
        ...,
        description='The id of the profile the token should grant access rights to.',
    )
    scopes: List[Scope3] = Field(
        ..., description='The scope(s) of the token(s) required.'
    )


class ProfileUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    heroAutoplay: Optional[bool] = Field(
        None, description='Sets the Hero row clip auto playback enabled'
    )
    heroWithAudio: Optional[bool] = Field(
        None, description='Sets the Hero row clip auto playback audio enabled'
    )
    languageCode: Optional[str] = Field(
        None,
        description='The code of the preferred language for the profile.\nMust be a valid ISO language code e.g. "en-US" and must match the code of\none of the languages specified in the app config.\nSee https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n',
    )
    name: Optional[constr(min_length=1)] = Field(
        None, description='The unique name of the profile.'
    )
    pinEnabled: Optional[bool] = Field(
        None,
        description='Whether an account pin is required to enter the profile.\n\nIf no account pin is defined this has no impact.\n',
    )
    purchaseEnabled: Optional[bool] = Field(
        None,
        description='Whether the profile can make purchases with the account payment options.',
    )
    segments: Optional[List[str]] = Field(
        None, description='The segments a profile should be placed under'
    )


class Purchase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    authorizationDate: Optional[datetime] = Field(
        None, description='The date the purchase was authorized.'
    )
    creationDate: datetime = Field(
        ..., description='The date the purchase was created.'
    )
    currency: str = Field(
        ..., description='The currency code used to make the purchase.'
    )
    id: str = Field(..., description='The identifier of the purchase.')
    item: Optional[ItemPurchase] = None
    paymentMethodId: Optional[str] = Field(
        None,
        description='The identifier of the payment method used to make the purchase.',
    )
    plan: Optional[PlanPurchase] = None
    total: float = Field(..., description='The total cost of the purchase.')


class PurchaseRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    itemId: Optional[str] = Field(
        None,
        description='The identifier of the item to purchase.\nBoth `itemId` and `offerId` are required for item purchases.\n',
    )
    offerId: Optional[str] = Field(
        None,
        description='The identifier of the item offer to purchase.\nBoth `itemId` and `offerId` are required for item purchases.\n',
    )
    paymentMethodId: Optional[str] = Field(
        None,
        description='The identifier of the payment method to use.\nIf omitted, or if purchasing a plan, the default payment method will be used.\n',
    )
    planId: Optional[str] = Field(
        None, description='The identifier of the plan to purchase.'
    )


class RegistrationRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email: str
    firstName: Optional[str] = None
    languageCode: Optional[str] = Field(
        None,
        description='The code of the preferred language for the primary profile.\nMust be a valid ISO language code e.g. "en-US" and must match the code of\none of the languages specified in the app config.\nSee https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n',
    )
    lastName: Optional[str] = None
    marketing: Optional[bool] = Field(
        True,
        description='Whether to receive marketing material or not. Default to true.',
    )
    password: str
    pin: Optional[str] = Field(None, description='The primary account pin.')
    segments: Optional[List[str]] = Field(
        None, description='The segments to apply to the primary profile.'
    )


class RokuPlanListItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: float = Field(
        ..., description='The price of a plan. If a free plan then undefined.'
    )
    currency: str = Field(..., description='The currency a plan is offered in.')
    description: str = Field(..., description='The textual description.')
    interval: Interval = Field(..., description='The type of billing period used.')
    intervalCount: int = Field(
        ...,
        description='Given the `interval` this is how frequently it will run. e.g. every 2 weeks.',
    )
    nickname: str = Field(..., description='The title of a plan.')
    product: str = Field(..., description='The product of a plan.')
    productCode: str = Field(..., description='The identifier of a plan.')
    savingLabel: str = Field(..., description='NA.')
    trialPeriodDays: int = Field(
        ...,
        description='How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.',
    )


class RokuPlans(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plans: List[RokuPlanListItem] = Field(
        ..., description='The list of available plans.'
    )
    termsAndConditions: str = Field(
        ..., description='Details of terms and conditions of the plan.'
    )


class SamsungPreviewSectionTile(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    action_data: str = Field(
        ..., description='Data to send to the application when the tile is clicked'
    )
    display_from: Optional[datetime] = Field(
        None, description='Time to begin showing the tile'
    )
    display_until: Optional[datetime] = Field(
        None, description='Time to stop showing the tile'
    )
    image_ratio: str = Field(
        ...,
        description='Thumbnail image aspect ratio\n  "16:9"\n  "4:3"\n  "1:1" (default)\n  "2:3"\n  The thumbnail height is fixed at 250 px on presentation.\n',
    )
    image_url: AnyUrl = Field(..., description='Thumbnail image URL')
    is_playable: bool = Field(
        ..., description='If "true", a "Play" icon is shown over the thumbnail image'
    )
    position: Optional[int] = Field(
        None,
        description='Section position. If specified, sections are shown in ascending position order',
    )
    subtitle: Optional[str] = Field(None, description='Tile subtitle')
    title: Optional[str] = Field(None, description='Tile title')


class ServiceError(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: Optional[int] = Field(
        None,
        description='An optional code classifying the error. Should be taken in the context of the http status code.',
    )
    message: str = Field(..., description='A description of the error.')


class Provider(Enum):
    Facebook = 'Facebook'


class Scope5(Enum):
    Catalog = 'Catalog'
    Commerce = 'Commerce'
    Settings = 'Settings'
    Playback = 'Playback'


class SingleSignOnRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cookieType: Optional[CookieType] = Field(
        None,
        description="If you specify a cookie type then a content filter cookie will be returned\nalong with the token(s). This is only intended for web based clients which\nneed to pass the cookies to a server to render a page based on the user's\ncontent filters e.g subscription code.\n\nIf type `Session` the cookie will be session based.\nIf type `Persistent` the cookie will have a medium term lifespan.\nIf undefined no cookies will be set.\n",
    )
    linkAccounts: Optional[bool] = Field(
        None,
        description='When a user attempts to sign in using single-sign-on, we may find an account created\npreviously through the manual sign up flow with the same email. If this is the\ncase then an option to link the two accounts can be made available.\n\nIf this flag is set to true then accounts will be linked automatically.\n\nIf this flag is not set or set to false and an existing account is found \nthen an http 401 with subcode `6001` will be returned. Client apps can then present the\noption to link the accounts. If the user decides to accept, then the same call\ncan be repeated with this flag set to true.\n',
    )
    provider: Provider = Field(
        ..., description='The third party single-sign-on provider.'
    )
    scopes: Optional[List[Scope5]] = Field(
        None,
        description='The scope(s) of the tokens required.\nFor each scope listed an Account and Profile token of that scope will be returned.\n',
    )
    token: str = Field(
        ...,
        description='A token from the third party single-sign-on provider e.g. an identity token from Facebook.',
    )


class Status(Enum):
    Active = 'Active'
    Cancelled = 'Cancelled'
    Lapsed = 'Lapsed'
    Expired = 'Expired'
    None_ = 'None'


class Subscription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: str = Field(..., description='The unique subscription code.')
    endDate: Optional[datetime] = Field(
        None,
        description='The end date of a subscription.\n\nAfter this date the subscription will become expired. If this is a recurring\nsubscription which has not been cancelled then the account holder will be\nautomatically charged and a new subscription will be activated.\n\nSome subscriptions may not have an end date, in which case this\nproperty will not exist.\n',
    )
    id: Optional[str] = Field(
        None, description='Unique identifier for the subscription.'
    )
    isTrialPeriod: bool = Field(
        ..., description='True if a subscription is in its trial period, false if not.'
    )
    planId: str = Field(..., description='The plan a subscription belongs to.')
    startDate: datetime = Field(..., description='The start date of a subscription.')
    status: Status = Field(..., description='The status of a subscription.')


class SubscriptionDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    itvData_purchased: Dict[str, Any] = Field(
        ..., description='The ITV purchased subscription data.'
    )


class Type9(Enum):
    Background = 'Background'
    Text = 'Text'
    Custom = 'Custom'


class ThemeColor(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='The name of the theme color.')
    opacity: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None,
        description='The opacity of the theme color from 0 to 1.\n\nWhen omitted, no opacity level is to be applied to the color, or in other words we\nassume the color has an opacity of 1\n',
    )
    value: str = Field(..., description='The hex value of the theme color.')


class TokenRefreshRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cookieType: Optional[CookieType] = Field(
        None,
        description="If you specify a cookie type then a content filter cookie will be returned\nalong with the token(s). This is only intended for web based clients which\nneed to pass the cookies to a server to render a page based on the user's\ncontent filters e.g subscription code.\n\nIf type `Session` the cookie will be session based.\nIf type `Persistent` the cookie will have a medium term lifespan.\nIf undefined no cookies will be set.\n",
    )
    token: str = Field(..., description='The token to refresh.')


class UserRating(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    itemId: str = Field(..., description='The id of the item rated.')
    rating: conint(ge=1, le=10) = Field(..., description='The rating out of 10')


class Watched(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    firstWatchedDate: datetime
    isFullyWatched: Optional[bool] = Field(
        False, description='True - if the item is fully watched, False - otherwise.'
    )
    itemId: Optional[str] = Field(None, description='The id of the item watched.')
    lastWatchedDate: datetime
    position: int = Field(
        ..., description='The last playhead position watched for the item.'
    )


class FfEnum(Enum):
    all = 'all'
    idp = 'idp'
    ldp = 'ldp'
    hb = 'hb'
    rpt = 'rpt'
    cas = 'cas'
    lrl = 'lrl'
    cd = 'cd'


class Ff(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff1(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountBillingMethodsGetResponse(RootModel[List[PaymentMethod]]):
    root: List[PaymentMethod]


class Ff2(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff3(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff4(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff5(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountBillingPurchasesGetResponse(RootModel[List[Purchase]]):
    root: List[Purchase]


class Ff6(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff7(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff8(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff9(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff10(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff11(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff12(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff13(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff14(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff15(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff16(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class DeliveryEnum(Enum):
    stream = 'stream'
    progressive = 'progressive'
    download = 'download'


class Resolution4(Enum):
    HD_4K = 'HD-4K'
    HD_1080 = 'HD-1080'
    HD_720 = 'HD-720'
    SD = 'SD'
    External = 'External'


class Format(Enum):
    mp4 = 'mp4'
    mpd = 'mpd'
    hls = 'hls'
    external = 'external'


class AccountItemsIdVideosGetResponse(RootModel[List[MediaFile]]):
    root: List[MediaFile]


class Delivery(RootModel[List[DeliveryEnum]]):
    root: List[DeliveryEnum]


class Formats(RootModel[List[Format]]):
    root: List[Format]


class Segments(RootModel[List[str]]):
    root: List[str]


class Ff17(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountItemsIdVideosGuardedGetResponse(RootModel[List[MediaFile]]):
    root: List[MediaFile]


class Delivery1(RootModel[List[DeliveryEnum]]):
    root: List[DeliveryEnum]


class Formats1(RootModel[List[Format]]):
    root: List[Format]


class Ff18(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff19(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff20(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff21(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff22(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountProfileBookmarksGetResponse(RootModel[Optional[Dict[str, datetime]]]):
    root: Optional[Dict[str, datetime]] = None


class Ff23(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff24(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff25(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff26(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff27(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ShowItemType(Enum):
    episode = 'episode'
    season = 'season'
    show = 'show'


class IncludeEnum(Enum):
    episode = 'episode'
    season = 'season'
    show = 'show'


class Include(RootModel[List[IncludeEnum]]):
    root: List[IncludeEnum]


class Ff28(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Expand(Enum):
    parent = 'parent'
    ancestors = 'ancestors'


class Ff29(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountProfileRatingsGetResponse(RootModel[Optional[Dict[str, int]]]):
    root: Optional[Dict[str, int]] = None


class Ff30(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class OrderBy1(Enum):
    date_added = 'date-added'
    date_modified = 'date-modified'


class Ff31(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff32(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff33(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItemId(RootModel[constr(min_length=1)]):
    root: constr(min_length=1) = Field(..., description='itemId to delete')


class ItemIds(RootModel[List[ItemId]]):
    root: List[ItemId] = Field(..., min_length=1)


class Ff34(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountProfileWatchedGetResponse(RootModel[Optional[Dict[str, Watched]]]):
    root: Optional[Dict[str, Watched]] = None


class Ff35(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff36(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff37(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff38(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff39(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff40(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff41(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff42(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff43(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff44(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AuthorizationPostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff45(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AuthorizationDevicePostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff46(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff47(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AuthorizationProfilePostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff48(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff49(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AuthorizationSsoPostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff50(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff51(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class IncludeEnum2(Enum):
    classification = 'classification'
    playback = 'playback'
    sitemap = 'sitemap'
    navigation = 'navigation'
    subscription = 'subscription'
    general = 'general'
    display = 'display'
    i18n = 'i18n'
    linear = 'linear'


class Include1(RootModel[List[IncludeEnum2]]):
    root: List[IncludeEnum2]


class Ff52(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff53(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff54(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff55(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Expand2(Enum):
    all = 'all'
    children = 'children'
    ancestors = 'ancestors'
    parent = 'parent'


class SelectSeason(Enum):
    first = 'first'
    latest = 'latest'


class Ff56(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff57(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff58(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItemsIdVideosGetResponse(RootModel[List[MediaFile]]):
    root: List[MediaFile]


class Delivery2(RootModel[List[DeliveryEnum]]):
    root: List[DeliveryEnum]


class Formats2(RootModel[List[Format]]):
    root: List[Format]


class Ff59(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Expand4(Enum):
    parent = 'parent'
    ancestors = 'ancestors'


class Ff60(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff61(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff62(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff63(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff64(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff65(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItvItemsummaryExternalIdGetResponse(BaseModel):
    pass


class ItemDetailExpand(Enum):
    all = 'all'
    children = 'children'
    ancestors = 'ancestors'


class ItemDetailSelectSeason(Enum):
    first = 'first'
    latest = 'latest'


class TextEntryFormat(Enum):
    markdown = 'markdown'
    html = 'html'


class Ff66(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItvPinauthorizationPostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff67(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItvProfileGetResponse(BaseModel):
    pass


class Ff68(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItemTypes(RootModel[List[constr(min_length=1)]]):
    root: List[constr(min_length=1)]


class Ff69(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class ItvResubscribePlatformPostResponse(BaseModel):
    pass


class OrderBy5(Enum):
    a_z = 'a-z'
    release_year = 'release-year'
    date_added = 'date-added'


class Ids(RootModel[List[str]]):
    root: List[str]


class Ff70(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff71(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff72(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff73(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class RegisterPostResponse(RootModel[List[AccessToken]]):
    root: List[AccessToken]


class Ff74(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff75(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff76(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class SchedulesGetResponse(RootModel[List[ItemScheduleList]]):
    root: List[ItemScheduleList]


class Channels(RootModel[List[str]]):
    root: List[str]


class Ff77(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class IncludeEnum4(Enum):
    tv = 'tv'
    movies = 'movies'
    people = 'people'
    other = 'other'


class Include2(RootModel[List[IncludeEnum4]]):
    root: List[IncludeEnum4]


class Ff78(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class Ff79(RootModel[List[FfEnum]]):
    root: List[FfEnum]


class AccountDevices(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    deregistrationWindow: Optional[DeviceRegistrationWindow] = None
    devices: List[Device] = Field(
        ..., description='The array of registered playack devices.'
    )
    maxRegistered: int = Field(
        ...,
        description='The maximum number of playback devices that can be registered\nunder an account at a single time.\n\nIf there is no maximum defined this value will be `-1`.\n',
    )
    registrationWindow: Optional[DeviceRegistrationWindow] = None


class AccountUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: Optional[Address] = None
    defaultPaymentInstrumentId: Optional[str] = Field(
        None,
        description='The id of the payment instrument to use by default for account transactions.\n\n**DEPRECATED** The property `defaultPaymentMethodId` is now preferred.\n',
    )
    defaultPaymentMethodId: Optional[str] = Field(
        None,
        description='The id of the payment method to use by default for account transactions.',
    )
    firstName: Optional[str] = Field(
        None, description='The first name of the account holder.'
    )
    lastName: Optional[str] = Field(
        None, description='The last name of the account holder.'
    )
    minRatingPlaybackGuard: Optional[str] = Field(
        None,
        description='The classification rating defining the minimum rating level a user should be\nforced to enter the account pin code for playback. Anything at this rating\nlevel or above will require the pin for playback.\n\ne.g. AUOFLC-MA15+\n\nIf you want to disable this guard pass an empty string or `null`.\n',
    )
    segments: Optional[List[str]] = Field(
        None, description='The segments an account should be placed under'
    )
    trackingEnabled: Optional[bool] = Field(
        None,
        description='Whether usage tracking is associated with an account or anonymous.',
    )


class AppConfigI18n(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    languages: List[Language] = Field(
        ..., description='An array of available languages.'
    )


class AppConfigSubscription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plans: Optional[List[Plan]] = Field(
        None, description='The available public plans a user can subscribe to.'
    )


class Classification(ClassificationSummary):
    advisoryText: Optional[str] = Field(None, description='Parental advisort text.')
    images: Dict[str, AnyUrl]
    level: int = Field(
        ...,
        description='The level of this classification when compared with its siblings.\nA higher level means a greater restriction.\nEach classification in a system should have a unique level.\n',
    )
    system: str = Field(
        ..., description='The parent system code of the classification.'
    )


class Credit(Person):
    character: Optional[str] = Field(None, description='The name of the character.')
    role: Role = Field(
        ..., description='The type of role the credit performed, e.g. actor.'
    )


class Entitlement(OfferRights):
    activationDate: Optional[datetime] = Field(
        None,
        description='The date of activation. If no date is defined the entitlement has not be activated.',
    )
    classification: Optional[ClassificationSummary] = None
    creationDate: Optional[datetime] = Field(
        None, description='The date the entitlement was created.'
    )
    expirationDate: Optional[datetime] = Field(
        None, description='The date the entitlement expires.'
    )
    itemId: Optional[str] = Field(
        None, description='The id of the item this entitlement is for.'
    )
    itemType: Optional[ItemType] = Field(
        None, description='The type of item this entitlement is for.'
    )
    mediaDuration: Optional[int] = Field(
        None, description='The duration of the entitled media.'
    )
    planId: Optional[str] = Field(
        None, description='The id of the plan this entitlement is for.'
    )
    playCount: Optional[int] = Field(
        None, description='How many times the media has been played.'
    )
    remainingDownloads: Optional[int] = Field(
        None, description='How many more downloads of this media are available.'
    )


class ItvBillingHistory(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    payment_history: List[ItvBillingHistoryRecord] = Field(
        ..., description='The array of objects with subscription payment details.'
    )


class ItvVoucherLinks(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    redeem: ItvVoucherLinksHref
    self: ItvVoucherLinksHref


class Offer(OfferRights):
    availability: Availability
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for an offer.'
    )
    endDate: Optional[datetime] = None
    id: Optional[str] = None
    name: Optional[str] = None
    price: float
    startDate: Optional[datetime] = None
    subscriptionCode: Optional[str] = Field(
        None,
        description='The code of the subscription this offer is offered under, if any.',
    )


class Pagination(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    authorization: Optional[PaginationAuth] = None
    next: Optional[str] = Field(
        None, description='Path to load next page of data, or null if not available'
    )
    options: Optional[PaginationOptions] = None
    page: conint(ge=0) = Field(
        ...,
        description='The current page number.\n\nA value of 0 indicates that the fist page has not yet been loaded. This is\nuseful when wanting to return the paging metadata to indicate how to\nload in the first page.\n',
    )
    previous: Optional[str] = Field(
        None,
        description='Path to load previous page of data, or null if not available.',
    )
    size: Optional[conint(ge=-1)] = Field(
        None,
        description='The current page size.\n\nA value of -1 indicates that the size has not yet been determined. This may\narise when embedding secure list pagination info in a page which must be cached\nby a CDN. For example a Bookmarks list.\n',
    )
    total: conint(ge=-1) = Field(
        ...,
        description='The total number of pages available given the current page size.\n\nA value of -1 indicates that the total has not yet been determined. This may\narise when embedding secure list pagination info in a page which must be cached\nby a CDN. For example a Bookmarks list.\n',
    )


class ProfileDetail(ProfileSummary):
    bookmarked: Dict[str, datetime] = Field(
        ..., description='A map of bookmarked itemIds => created date'
    )
    rated: Dict[str, int] = Field(
        ..., description='A map of rated itemIds => rating out of 10'
    )
    watched: Dict[str, Watched] = Field(
        ..., description='A map of watched itemIds => last watched position'
    )


class SamsungPreviewSection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    position: Optional[int] = Field(
        None,
        description='Section position. If specified, sections are shown in ascending position order.',
    )
    tiles: List[SamsungPreviewSectionTile] = Field(
        ..., description='Tiles within the section'
    )
    title: Optional[str] = Field(None, description='Section title')


class Theme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    colors: List[ThemeColor] = Field(
        ..., description='The list of colors defined for the theme.'
    )
    type: Type9 = Field(..., description='The type of theme.')


class AccountEntitlementsGetResponse(RootModel[List[Entitlement]]):
    root: List[Entitlement]


class Account(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    address: Optional[Address] = None
    defaultPaymentInstrumentId: Optional[str] = Field(
        None,
        description='The id of the payment instrument to use by default for account transactions.\n\n **DEPRECATED** The property `defaultPaymentMethodId` is now preferred.\n',
    )
    defaultPaymentMethodId: Optional[str] = Field(
        None,
        description='The id of the payment method to use by default for account transactions.',
    )
    emailVerified: Optional[bool] = Field(
        None,
        description='Whether the email address has been verified.\n\nUsers who receive an emailed verification url click the link to verify their email address.\n',
    )
    entitlements: Optional[List[Entitlement]] = Field(
        None, description='The list of entitlements to playback specific items.'
    )
    firstName: Optional[str] = Field(
        None, description='The first name of the account holder.'
    )
    id: str = Field(..., description='The id of the account.')
    isFirstTimeSubscriber: Optional[bool] = Field(
        None, description='Whether the account has the very first subscription.'
    )
    lastName: Optional[str] = Field(
        None, description='The last name of the account holder.'
    )
    marketingEnabled: bool = Field(
        ...,
        description='Whether the account has opted in or out of marketing material.',
    )
    minRatingPlaybackGuard: Optional[str] = Field(
        None,
        description='The classification rating defining the minimum rating level a user should be\nforced to enter the account pin code for playback. Anything at this rating\nlevel or above will require the pin for playback.\n\ne.g. AUOFLC-MA15+\n\nIf you want to disable this guard pass an empty string or `null`.\n',
    )
    pinEnabled: bool = Field(
        ..., description='When an account level pin is defined this will be true.'
    )
    primaryProfileId: str = Field(..., description='The id of the primary profile.')
    profiles: List[ProfileSummary] = Field(
        ..., description='The list of profiles under this account.'
    )
    segments: Optional[List[str]] = Field(
        None, description='The segments an account has been placed under'
    )
    subscriptionCode: str = Field(
        ...,
        description='The active subscription code for an account.\n\nThe value of this should be passed to any endpoints accepting a `sub` query parameter.\n',
    )
    subscriptions: Optional[List[Subscription]] = Field(
        None,
        description='The list of subscriptions, if any, the account has signed up to.',
    )
    trackingEnabled: bool = Field(
        ...,
        description='Whether usage tracking is associated with the account or anonymous.',
    )
    usedFreeTrial: Optional[bool] = Field(
        None,
        description='Whether the account has used up their free trial period of a plan.',
    )


class AppConfigDisplay(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    themes: List[Theme] = Field(
        ..., description='An array of globally configured themes.'
    )


class ItemSummary(BaseModel):
    advisoryText: Optional[str] = Field(
        None, description='Advisory text about this item, related to the classification'
    )
    availableEpisodeCount: Optional[int] = Field(
        None,
        description='The number of available episodes in the season, if the item is a season.',
    )
    availableSeasonCount: Optional[int] = Field(
        None,
        description='The number of available seasons in the show, if the item is a show.',
    )
    averageUserRating: Optional[confloat(ge=0.0)] = Field(
        None,
        description='The average user rating.\nWhen based on user ratings from our system this will be out of 10.\n',
    )
    badge: Optional[str] = Field(None, description='The badge this item has.')
    channelShortCode: Optional[str] = Field(
        None, description='The channel short code, if the item is a channel.'
    )
    classification: Optional[ClassificationSummary] = None
    contextualTitle: Optional[str] = Field(
        None,
        description='A contextually relative title to display after a parent title.\nMostly applicable to Season, Episode and Trailer.\n',
    )
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for an item.'
    )
    customId: Optional[str] = Field(
        None,
        description='A custom identifier for this item.\nFor example the id for this item under a different content system.\n',
    )
    duration: Optional[conint(ge=0)] = Field(
        None, description='The duration of the media in seconds.'
    )
    episodeCount: Optional[int] = Field(
        None,
        description='The number of episodes in the season, if the item is a season.',
    )
    episodeName: Optional[str] = Field(None, description='The full name of an episode.')
    episodeNumber: Optional[int] = Field(
        None, description='The number of an episode, if the item is an episode.'
    )
    genres: Optional[List[str]] = Field(
        None, description='The array of genres this item belongs to.'
    )
    hasClosedCaptions: Optional[bool] = Field(
        None, description='Whether closed captioning is available.'
    )
    id: str = Field(..., description='Unique identifier for an Item')
    images: Optional[Dict[str, AnyUrl]] = None
    offers: Optional[List[Offer]] = Field(
        None, description='The array of available offers for this item.'
    )
    path: str = Field(
        ...,
        description='The path to the detail page of this item. Can be used to load the item detail page via the /page endpoint.',
    )
    releaseYear: Optional[int] = Field(
        None, description='The year this item was released'
    )
    scopes: Optional[List[str]] = Field(None, description='The scopes for this item')
    seasonId: Optional[str] = Field(
        None,
        description='The identifier of the season this item belongs to, if the item is an episode.',
    )
    seasonNumber: Optional[int] = Field(
        None, description='The number of a season, if the item is a season.'
    )
    shortDescription: Optional[str] = Field(
        None, description='A truncated description of the item'
    )
    showId: Optional[str] = Field(
        None,
        description='The identifier of the show this item belongs to, if the item is a season or episode.',
    )
    showTitle: Optional[str] = None
    subtype: Optional[str] = Field(
        None,
        description='Subtype of the item. Mainly used to identify different types when `type`\nis `customAsset`\n',
    )
    tagline: Optional[str] = Field(None, description='The tagline of the item')
    themes: Optional[List[Theme]] = Field(
        None, description='Gets themes associated with the item'
    )
    title: str = Field(..., description='The display title of the item.')
    type: Type2 = Field(..., description='The type of item')
    watchPath: Optional[str] = Field(
        None,
        description='The path to watch this item, if the item is a watchable type, e.g. a `movie`, `program` and `episode`.',
    )


class ItvVoucher(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    display: ItvVoucherDisplay
    id: str = Field(..., description='The coupon/voucher.')
    links: ItvVoucherLinks
    offerType: OfferType = Field(..., description='The voucher offer type.')


class SamsungPreview(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expires: Optional[int] = Field(
        None,
        description='For public preview only\nIf specified, the time at which the preview content is updated.\nThe time is at most 1 week into the future. By default, the preview\ncontent is updated every 10 minutes, whenever the TV is switched on,\nor the JSON file changes.\n',
    )
    expires_only: Optional[bool] = Field(
        False,
        description='For public preview only\nIf this value is "true", the preview content is updated only at\nthe time specified by the "expires" parameter.\n',
    )
    sections: List[SamsungPreviewSection] = Field(..., description='Preview sections')


class ContinueWatchingListDataExpansion(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    episode: Optional[ItemSummary] = None
    season: Optional[ItemSummary] = None
    show: Optional[ItemSummary] = None


class ContinueWatchingListData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    itemInclusions: Optional[Dict[str, ContinueWatchingListDataExpansion]] = Field(
        None,
        description='Object where keys are itemIds for the items in the list and values are objects\ncontaining additional items (either episode/season/show) that were requested\nin the "include" query option.\n\nFor example if you request the ContinueWatching list with "season" items in\nthe list, you can specify `include=episode` and then the specific next episode\nwill be returned in this object.\n',
    )


class ListData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ContinueWatching: Optional[ContinueWatchingListData] = None


class ItemList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for a list.'
    )
    description: Optional[str] = Field(
        None, description='A full description of this list.'
    )
    id: str = Field(..., description='The id of this list')
    images: Optional[Dict[str, AnyUrl]] = None
    itemTypes: Optional[List[ItemType]] = Field(
        None, description='The types of items in the list'
    )
    items: List[ItemSummary] = Field(..., description='A list of items')
    listData: Optional[ListData] = None
    paging: Pagination
    parameter: Optional[str] = Field(
        None,
        description='If this list is parameterized, then this contains the parameter of the list in the format `name:value`.\nFor example the Movies Genre list will take a parameter `genre` with a given value. e.g. `genre:action` or `genre:drama`.',
    )
    path: str = Field(..., description='The path of this list')
    shortDescription: Optional[str] = Field(
        None, description='A short description of this list.'
    )
    size: int = Field(..., description='The total size of the list')
    tagline: Optional[str] = Field(None, description='The tagline of the item.')
    themes: Optional[List[Theme]] = None
    title: Optional[str] = Field(None, description='The title of this list')


class NavContent(BaseModel):
    imageType: Optional[str] = Field(
        None,
        description='The image type to target when rendering items of the list.\n\ne.g wallpaper, poster, hero3x1, logo.\n',
    )
    list: Optional[ItemList] = None
    title: Optional[str] = Field(
        None, description='The title of the embedded navigation content.'
    )


class NavEntry(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    children: Optional[List[NavEntry]] = Field(None, description='Child nav entries.')
    content: Optional[NavContent] = None
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for a nav entry.'
    )
    depth: conint(ge=0) = Field(
        ..., description='The depth of the NavEntry (top level is 0)'
    )
    featured: Optional[bool] = Field(
        None,
        description='True if this is a featured menu item.\n\nFeatured menu items may have a more prominent presentation than others in the navigation.\n',
    )
    icon: Optional[str] = Field(None, description='The icon for this nav entry.')
    label: Optional[str] = Field(None, description='The text label for this nav entry.')
    path: Optional[str] = Field(
        None,
        description="The path this nav entry links to.\nMay be undefined if the nav entry is not clickable e.g. a nav heading.\nIf the value begins with `http` then it's an external url.\n",
    )


class Navigation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account: Optional[NavEntry] = None
    copyright: Optional[str] = Field(None, description='Copyright information.')
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for navigation.'
    )
    footer: Optional[NavEntry] = None
    header: List[NavEntry] = Field(..., description='The header navigation.')
    mobile: Optional[NavEntry] = None


class PageEntry(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFields: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of custom fields defined by a curator for a page entry.',
    )
    id: str = Field(..., description='The unique identifier for a page entry.')
    images: Optional[Dict[str, AnyUrl]] = Field(
        None,
        description='The images for the page entry if any.\n\nFor example the images of an `ImageEntry`.\n',
    )
    item: Optional[ItemSummary] = None
    list: Optional[ItemList] = None
    people: Optional[List[Person]] = Field(
        None,
        description="If 'type' is 'PeopleEntry' then this is the array of people to present.",
    )
    template: str = Field(
        ..., description='Template type used to present the content of the PageEntry.'
    )
    text: Optional[str] = Field(
        None,
        description="If 'type' is 'TextEntry' then this is the text to be represented.",
    )
    title: str = Field(..., description='The name of the Page Entry.')
    type: Type4 = Field(
        ...,
        description='The type of PageEntry. Used to help identify what type of content will be presented.',
    )


class SearchResults(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    items: Optional[ItemList] = None
    movies: Optional[ItemList] = None
    other: Optional[ItemList] = None
    people: Optional[List[Person]] = Field(
        None, description='The list of people relevant to the search term.'
    )
    term: str = Field(..., description='The search term.')
    total: conint(ge=0) = Field(..., description='The total number of results.')
    tv: Optional[ItemList] = None


class ListsGetResponse(RootModel[List[ItemList]]):
    root: List[ItemList]


class AppConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classification: Optional[Dict[str, Classification]] = Field(
        None, description='The map of classification ratings.'
    )
    display: Optional[AppConfigDisplay] = None
    general: Optional[AppConfigGeneral] = None
    i18n: Optional[AppConfigI18n] = None
    linear: Optional[AppConfigLinear] = None
    navigation: Optional[Navigation] = None
    playback: Optional[AppConfigPlayback] = None
    sitemap: Optional[List[PageSummary]] = None
    subscription: Optional[AppConfigSubscription] = None


class ItemDetail(ItemSummary):
    copyright: Optional[str] = Field(
        None, description='Copyright information about this item'
    )
    credits: Optional[List[Credit]] = Field(
        None, description='A list of credits associated with this item.'
    )
    customMetadata: Optional[List[ItemCustomMetadata]] = Field(
        None,
        description='An ordered list of custom name-value-pair item metadata.\n\nUsually displayed on an item detail page.\n',
    )
    description: Optional[str] = Field(
        None, description='The description of this item.'
    )
    distributor: Optional[str] = Field(
        None, description='The distributor of this item.'
    )
    episodes: Optional[ItemList] = None
    eventDate: Optional[datetime] = Field(
        None,
        description='The optional date of an event.\nSpecific to a Program item type.\n',
    )
    genrePaths: Optional[List[str]] = Field(
        None,
        description='An array of genre paths mapping to the values within the `genres` array from ItemSummary.\n',
    )
    location: Optional[str] = Field(
        None,
        description='The optional location (e.g. city) of an event.\nSpecific to a Program item type.\n',
    )
    season: Optional[ItemDetail] = None
    seasons: Optional[ItemList] = None
    show: Optional[ItemDetail] = None
    totalUserRatings: Optional[conint(ge=0)] = Field(
        None, description='The total number of users who have rated this item.'
    )
    trailers: Optional[List[ItemSummary]] = Field(
        None, description='A list of trailers associated with this item.'
    )
    venue: Optional[str] = Field(
        None,
        description='The optional venue of an event.\nSpecific to a Program item type.\n',
    )


class NextPlaybackItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    firstWatchedDate: Optional[datetime] = Field(
        None,
        description='Time when the item corresponding to the itemId passed in by the client was\nfirst watched by the user. Will be `undefined` if the user has never\nwatched the item.\n\nIt can be used to identify the scenario where the user has never watched a\nshow and we are suggesting they watch the first episode (i.e. it is\nmissing in this scenario)\n\n**This will only be populated when a `showId` is passed in**\n',
    )
    lastWatchedDate: Optional[datetime] = Field(
        None,
        description='Time when the item corresponding to the itemId passed in by the client was\nlast watched by the user. Will be `undefined` if the user has never\nwatched the item.\n\nIt can be used to identify the scenario where the user has never watched a\nshow and we are suggesting they watch the first episode (i.e. it is\nmissing in this scenario)\n\n**This will only be populated when a `showId` is passed in**\n',
    )
    next: Optional[ItemDetail] = None
    sourceItemId: str = Field(
        ..., description='The id of the item used to determine the next item to play.'
    )
    suggestionType: Optional[SuggestionType] = Field(
        None,
        description='Field indicating the type or reason behind the suggestion.\n\nId Type   | Show Watched Status| Value            | Description\n----------|--------------------|------------------|---------------------------------\nshowId    | Unwatched          | StartWatching    |\nshowId    | Completely watched | RestartWatching  |\nshowId    | Partly watched     | ContinueWatching | Suggested episode partly watched\nshowId    | Partly watched     | Sequential       | Suggested episode unwatched\nepisodeId | Any                | Sequential       | Next episode in show\n',
    )


class Page(PageSummary):
    customFields: Optional[Dict[str, Any]] = Field(
        None, description='A map of custom fields defined by a curator for a page.'
    )
    entries: List[PageEntry] = Field(..., description='Entries of a page')
    item: Optional[ItemDetail] = None
    list: Optional[ItemList] = None
    metadata: Optional[PageMetadata] = None
    themes: Optional[List[Theme]] = None


NavEntry.model_rebuild()
ItemDetail.model_rebuild()
