# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:32:42+00:00



import argparse
import json
import os
from datetime import date
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    APIKeyHeader,
    BaseSecurity,
    OAuth2PasswordBearer,
)
from fastapi import Path, Query
from pydantic import conint

from models import (
    AccessToken,
    Account,
    AccountBillingMethodsGetResponse,
    AccountBillingPurchasesGetResponse,
    AccountDevices,
    AccountEntitlementsGetResponse,
    AccountItemsIdVideosGetResponse,
    AccountItemsIdVideosGuardedGetResponse,
    AccountNonce,
    AccountProfileBookmarksGetResponse,
    AccountProfileRatingsGetResponse,
    AccountProfileWatchedGetResponse,
    AccountTokenByCodeRequest,
    AccountTokenRequest,
    AccountUpdateRequest,
    AddPaymentMethodRequest,
    AppConfig,
    AuthorizationDevicePostResponse,
    AuthorizationPostResponse,
    AuthorizationProfilePostResponse,
    AuthorizationSsoPostResponse,
    Bookmark,
    BtPlanListItem,
    BtPlans,
    ChangePasswordRequest,
    ChangePinRequest,
    Channels,
    Delivery,
    Delivery1,
    Delivery2,
    Device,
    DeviceAuthorizationCode,
    DeviceRegistrationRequest,
    EeBtEligibility,
    EeCreatePinRequest,
    EeCreatePinResponse,
    EeCreateTokenResponse,
    EeOffersRequest,
    EeOffersResponse,
    EePlanListItem,
    EePlans,
    EeValidatePinRequest,
    EeValidatePinResponse,
    Entitlement,
    Expand,
    Expand2,
    Expand4,
    Ff,
    Ff1,
    Ff2,
    Ff3,
    Ff4,
    Ff5,
    Ff6,
    Ff7,
    Ff8,
    Ff9,
    Ff10,
    Ff11,
    Ff12,
    Ff13,
    Ff14,
    Ff15,
    Ff16,
    Ff17,
    Ff18,
    Ff19,
    Ff20,
    Ff21,
    Ff22,
    Ff23,
    Ff24,
    Ff25,
    Ff26,
    Ff27,
    Ff28,
    Ff29,
    Ff30,
    Ff31,
    Ff32,
    Ff33,
    Ff34,
    Ff35,
    Ff36,
    Ff37,
    Ff38,
    Ff39,
    Ff40,
    Ff41,
    Ff42,
    Ff43,
    Ff44,
    Ff45,
    Ff46,
    Ff47,
    Ff48,
    Ff49,
    Ff50,
    Ff51,
    Ff52,
    Ff53,
    Ff54,
    Ff55,
    Ff56,
    Ff57,
    Ff58,
    Ff59,
    Ff60,
    Ff61,
    Ff62,
    Ff63,
    Ff64,
    Ff65,
    Ff66,
    Ff67,
    Ff68,
    Ff69,
    Ff70,
    Ff71,
    Ff72,
    Ff73,
    Ff74,
    Ff75,
    Ff76,
    Ff77,
    Ff78,
    Ff79,
    Formats,
    Formats1,
    Formats2,
    Ids,
    Include,
    Include1,
    Include2,
    ItemClipFilesList,
    ItemDetail,
    ItemDetailExpand,
    ItemDetailSelectSeason,
    ItemDownloadableList,
    ItemDownloadableRequest,
    ItemIds,
    ItemList,
    ItemsIdVideosGetResponse,
    ItemType,
    ItemTypes,
    ItvAssignBtTokenRequest,
    ItvAssignMsisdnRequest,
    ItvBillingHistory,
    ItvBillingHistoryRequest,
    ItvCancelSubscriptionRequest,
    ItvCardDetails,
    ItvChangeCardDetailsRequest,
    ItvChangeEmailRequest,
    ItvChangeMarketingRequest,
    ItvCurrentSubscription,
    ItvDeleteAccountRequest,
    ItvEntitlementCurrent,
    ItvEntitlementsHistory,
    ItvFeatureFlag,
    ItvGetCardDetailsRequest,
    ItvGetDiscountResponse,
    ItvGooglePaySubscriptionRequest,
    ItvHadEntitlement,
    ItvItemsummaryExternalIdGetResponse,
    ItvPinauthorizationPostResponse,
    ItvPinAuthRequest,
    ItvPlans,
    ItvProfileGetResponse,
    ItvProfileToken,
    ItvProfileTokenRequest,
    ItvPurchase,
    ItvPurchaseRequest,
    ItvPurchaseStrongRequest,
    ItvPurchaseStrongResponse,
    ItvPurchaseWithOfferRequest,
    ItvPurchaseWithOfferResponse,
    ItvResubscribePlatformPostResponse,
    ItvRokuTransactionRequest,
    ItvSubscriptionFullPriceRenewal,
    ItvSubscriptionState,
    ItvSubscriptionStatusResponse,
    ItvUpdateIntentStrongRequest,
    ItvUpdateIntentStrongResponse,
    ItvUpdatePaymentStrongRequest,
    ItvUpdateProfileRequest,
    ItvUpgradePlanRequest,
    ItvVoucher,
    ItvVoucherRequest,
    ListsGetResponse,
    NextPlaybackItem,
    Order,
    OrderBy1,
    OrderBy5,
    Page,
    PasswordResetEmailRequest,
    PasswordResetRequest,
    PaymentMethod,
    Plan,
    ProfileCreationRequest,
    ProfileDetail,
    ProfileSummary,
    ProfileTokenRequest,
    ProfileUpdateRequest,
    PurchaseRequest,
    RegisterPostResponse,
    RegistrationRequest,
    Resolution4,
    RokuPlans,
    SamsungPreview,
    SchedulesGetResponse,
    SearchResults,
    Segments,
    SelectSeason,
    ServiceError,
    ShowItemType,
    SingleSignOnRequest,
    SubscriptionDetails,
    TextEntryFormat,
    TokenRefreshRequest,
    UserRating,
    Watched,
)

app = MCPProxy(
    description='An Orchestration Layer that takes ISL services and packages them in a more targeted way for front-end applications.\nThis in turn makes client integration easier and reduces the complexity and size of front-end applications.\n\nRocket is also customisable - allowing UI engineers to ‘remix’ the existing back-end services into something that\nbest suits the application they are developing.\n',
    title='Rocket Services',
    version='3.730.300-ref-1-39-0',
    servers=[{'url': '/api'}],
)


@app.get(
    '/account',
    description=""" Get the details of an account along with the profiles and entitlements under it. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_account(ff: Optional[Ff] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/account',
    description=""" Update the details of an account.

With the exception of the address, this supports partial updates, so you can send just the
properties you wish to update.

When the address is provided any properties which are omitted from the address will be cleared.
 """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_account(
    ff: Optional[Ff1] = None,
    lang: Optional[str] = None,
    body: AccountUpdateRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/billing/methods',
    description=""" Get the available payment methods under an account. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_payment_methods(ff: Optional[Ff2] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/billing/methods',
    description=""" Add a new payment method to an account. """,
    tags=['payment_methods_management', 'billing_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def add_payment_method(
    ff: Optional[Ff3] = None,
    lang: Optional[str] = None,
    body: AddPaymentMethodRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/billing/methods/{id}',
    description=""" Remove a payment method from an account. """,
    tags=['user_profile_operations', 'profile_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def remove_payment_method(
    id: str, ff: Optional[Ff4] = None, lang: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/billing/methods/{id}',
    description=""" Get a payment method under an account. """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_payment_method(id: str, ff: Optional[Ff5] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/billing/purchases',
    description=""" Get a list of all purchases made under an account. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_purchases(ff: Optional[Ff6] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/billing/purchases',
    description=""" Purchase a plan or item offer.
The result of a successful transaction is a new entitlement.
 """,
    tags=['purchase_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def make_purchase(
    ff: Optional[Ff7] = None, lang: Optional[str] = None, body: PurchaseRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/billing/subscriptions/{id}',
    description=""" Cancel a plan subscription.

A cancelled subscription will continue to be valid until the subscription
expiry date or next renewal date.
 """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def cancel_subscription(id: str, ff: Optional[Ff8] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/billing/subscriptions/{id}',
    description=""" Renew a cancelled subscription or switch subscription to a different plan.

When renewing a cancelled subscription membership, hit this endpoint with
the id of subscription to renew.

To switch plans provide the id of the current active subscription membership
of the account, and in the query specify the id of the plan to switch to.
 """,
    tags=['plan_information_retrieval', 'subscription_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_subscription(
    id: str,
    plan_id: Optional[str] = Query(None, alias='planId'),
    ff: Optional[Ff9] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/devices',
    description=""" Get all devices registered under this account.

Also includes information around device registration and deregistration limits.
 """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_devices(ff: Optional[Ff10] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/devices',
    description=""" Register a playback device under an account.

If a device with the same id already exists a `409` conflict will be returned.
 """,
    tags=['device_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def register_device(
    ff: Optional[Ff11] = None,
    lang: Optional[str] = None,
    body: DeviceRegistrationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/devices/authorization',
    description=""" Authorize a device from a generated device authorization code.

This is the second step in the process of authorizing a device by pin code.

Firstly the device must request a generated authorization code via the
`/authorization/device/code` endpoint.

This endpoint then authorizes the device associated with the code to sign in
to a user account. Typically this endpoint will be called from a page
presented in the web app under the account section.

Once authorized, the device will then be able to sign in to that account
via the `/authorization/device` endpoint, without needing to provide the 
credentials of the user.
 """,
    tags=['device_management', 'user_authentication_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def authorize_device(
    ff: Optional[Ff12] = None,
    lang: Optional[str] = None,
    body: DeviceAuthorizationCode = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/devices/{id}',
    description=""" Deregister a playback device from an account. """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def deregister_device(id: str, ff: Optional[Ff13] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/devices/{id}',
    description=""" Get a registered device. """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_device(id: str, ff: Optional[Ff14] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/devices/{id}/name',
    description=""" Rename a device """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def rename_device(
    id: str, name: str = ..., ff: Optional[Ff15] = None, lang: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/entitlements',
    description=""" Get all entitlements under the account.

This list is returned under the call to get account information so a call here is
only required when wishing to refresh a local copy of entitlements.
 """,
    tags=['user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_entitlements(ff: Optional[Ff16] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/items/{id}/videos',
    description=""" Get the video files associated with an item given maximum resolution, device type
and one or more delivery types.

This endpoint accepts an Account Catalog token, however if when requesting
playback files you receive an *403 status code with error code 1* then the file
you're requesting is classification restricted. This means you should switch
to target the `/account/items/{id}/videos-guarded` endpoint, passing it an Account
Playback token. If not already obtained, this token can be requested via the
`/itv/pinauthorization` endpoint with an account level pin.

For convenience you may also access free / public files through this endpoint
instead of the /items/{id}/videos endpoint, when authenticated.

Returns an array of video file objects which each include a url to a video.

The first entry in the array contains what is predicted to be the best match.
The remainder of the entries, if any, may contain resolutions below what was
requests. For example if you request HD-720 the response may also contain
SD entries.

If you specify multiple delivery types, then the response array will insert
types in the order you specify them in the query. For example `stream,progressive`
would return an array with 0 or more stream files followed by 0 or more progressive files.

If no files are found a 404 is returned.
 """,
    tags=['entitlement_retrieval', 'item_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_item_media_files(
    id: str,
    delivery: Delivery = ...,
    resolution: Resolution4 = ...,
    formats: Optional[Formats] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff17] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/items/{id}/videos-guarded',
    description=""" Get the video files associated with an item given maximum resolution, device type
and one or more delivery types.

This endpoint is identical to the `/account/items/{id}/videos` however it expects
an Account Playback token. This token, and in association this endpoint, is specifically
for use when playback files are classification restricted and require an account
level pin to access them.

Returns an array of video file objects which each include a url to a video.

The first entry in the array contains what is predicted to be the best match.
The remainder of the entries, if any, may contain resolutions below what was
requests. For example if you request HD-720 the response may also contain
SD entries.

If you specify multiple delivery types, then the response array will insert
types in the order you specify them in the query. For example `stream,progressive`
would return an array with 0 or more stream files followed by 0 or more progressive files.

If no files are found a 404 is returned.
 """,
    tags=['entitlement_retrieval', 'item_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_item_media_files_guarded(
    id: str,
    delivery: Delivery1 = ...,
    resolution: Resolution4 = ...,
    formats: Optional[Formats1] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff18] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/nonce',
    description=""" Generate a new account nonce.

A nonce may be required to help sign a response from a third party
service which will be passed back to these services.

For example a Facebook single-sign-on request initiated by a client
application may first get a nonce from here to include in the request.
Facebook will then include the nonce in the auth token it issues. This
token can be passed back to our services and the nonce checked for validity.
 """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def generate_nonce(ff: Optional[Ff19] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/password',
    description=""" Change the password of an account.

The expected token scope is Settings.
 """,
    tags=['security_operations', 'user_authentication_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def change_password(
    ff: Optional[Ff20] = None,
    lang: Optional[str] = None,
    body: ChangePasswordRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/pin',
    description=""" Change the pin of an account. """,
    tags=['security_operations', 'pin_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def change_pin(
    ff: Optional[Ff21] = None, lang: Optional[str] = None, body: ChangePinRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile',
    description=""" Get the details of the active profile, including watched, bookmarked and rated items. """,
    tags=['user_authentication_management'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_profile(ff: Optional[Ff22] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/bookmarks',
    description=""" Get the map of bookmarked item ids (itemId => creationDate) under the active profile. """,
    tags=['account_management', 'user_authentication_management'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_bookmarks(ff: Optional[Ff23] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/bookmarks/list',
    description=""" Returns the list of bookmarked items under the active profile. """,
    tags=['item_list_management', 'content_search_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_bookmark_list(
    page: Optional[conint(ge=1)] = None,
    page_size: Optional[conint(ge=1, le=50)] = None,
    order: Optional[Order] = 'desc',
    item_type: Optional[ItemType] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff24] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/profile/bookmarks/{itemId}',
    description=""" Unbookmark an item under the active profile. """,
    tags=['item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def delete_item_bookmark(
    item_id: str = Path(..., alias='itemId'),
    ff: Optional[Ff25] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/bookmarks/{itemId}',
    description=""" Get the bookmark for an item under the active profile. """,
    tags=['item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_item_bookmark(
    item_id: str = Path(..., alias='itemId'),
    ff: Optional[Ff26] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/profile/bookmarks/{itemId}',
    description=""" Bookmark an item under the active profile.

Creates one if it doesn't exist, overwrites one if it does.
 """,
    tags=['item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def bookmark_item(
    item_id: str = Path(..., alias='itemId'),
    ff: Optional[Ff27] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/continue-watching/list',
    description=""" Returns a list of items which have been watched but not completed under the active
profile.

Multiple episodes under the same show may be watched or in progress, however only a
single item belonging to a particular show will be included in the returned list.

The next episode to continue watching for a particular show will be the most recent
incompletely watched episode, or the next episode following the most recently
completely watched episode. Based on the specified `show_item_type` type, either the next
episode, the season of the next episode, or the show will be included in the list.
 """,
    tags=['item_operations', 'item_list_management', 'content_search_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_continue_watching_list(
    show_item_type: Optional[ShowItemType] = 'episode',
    include: Optional[Include] = [],
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=50)] = 12,
    max_rating: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff28] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/items/{itemId}/next',
    description=""" Returns the next item to play given a source item id.

For an unwatched show it returns the first episode available to the account.

For a watched show it returns the last incompletely watched episode by the profile,
or the episode that immediately follows the last completely watched episode 
or nothing.

For an episode it always returns the immediately following episode, if available to
the account, or nothing.

If the response does not contain a `next` property then no item was found.
 """,
    tags=['rating_system_management', 'item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_next_playback_item(
    item_id: str = Path(..., alias='itemId'),
    max_rating: Optional[str] = None,
    expand: Optional[Expand] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff29] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/ratings',
    description=""" Get the map of rated item ids (itemId => rating out of 10) under the active profile. """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_ratings(ff: Optional[Ff30] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/ratings/list',
    description=""" Returns the list of rated items under the active profile. """,
    tags=['item_list_management', 'content_search_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_ratings_list(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=50)] = 12,
    order: Optional[Order] = 'desc',
    order_by: Optional[OrderBy1] = 'date-added',
    item_type: Optional[ItemType] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff31] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/ratings/{itemId}',
    description=""" Get the rating info for an item under the active profile. """,
    tags=['item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_item_rating(
    item_id: str = Path(..., alias='itemId'),
    ff: Optional[Ff32] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/profile/ratings/{itemId}',
    description=""" Rate an item under the active profile.

Creates one if it doesn't exist, overwrites one if it does.
 """,
    tags=['rating_system_management', 'item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def rate_item(
    item_id: str = Path(..., alias='itemId'),
    rating: conint(ge=1, le=10) = ...,
    ff: Optional[Ff33] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/profile/watched',
    description=""" Remove the watched status of items under the active profile. Passing in
specific `itemId`s to the `item_ids` query parameter will cause only these
items to be removed. **If this list is missing all watched items will be
removed**
 """,
    tags=['item_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def delete_watched(
    item_ids: Optional[ItemIds] = None,
    ff: Optional[Ff34] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/watched',
    description=""" Get the map of watched item ids (itemId => last playhead position) under the active profile. """,
    tags=['account_management', 'user_authentication_management'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_watched(ff: Optional[Ff35] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/watched/list',
    description=""" Returns the list of watched items under the active profile. """,
    tags=['item_operations', 'item_list_management'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_watched_list(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=50)] = 12,
    completed: Optional[bool] = None,
    order: Optional[Order] = 'desc',
    order_by: Optional[OrderBy1] = 'date-added',
    item_type: Optional[ItemType] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff36] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profile/watched/{itemId}',
    description=""" Get the watched status info for an item under the active profile. """,
    tags=['item_operations', 'entitlement_retrieval'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_item_watched_status(
    item_id: str = Path(..., alias='itemId'),
    ff: Optional[Ff37] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/profile/watched/{itemId}',
    description=""" Record the watched playhead position of a video under the active profile.

Can be used later to resume a video from where it was last watched.

Creates one if it doesn't exist, overwrites one if it does.
 """,
    tags=['item_operations', 'bookmark_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def set_item_watched_status(
    item_id: str = Path(..., alias='itemId'),
    position: conint(ge=0) = ...,
    ff: Optional[Ff38] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/profiles',
    description=""" Create a new profile under the active account. """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def create_profile(
    ff: Optional[Ff39] = None,
    lang: Optional[str] = None,
    body: ProfileCreationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/profiles/{id}',
    description=""" Delete a profile with a specific id under the active account.

Note that you cannot delete the primary profile.
 """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def delete_profile_with_id(
    id: str, ff: Optional[Ff40] = None, lang: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/profiles/{id}',
    description=""" Get the summary of a profile with a specific id under the active account. """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_profile_with_id(id: str, ff: Optional[Ff41] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/account/profiles/{id}',
    description=""" Update the summary of a profile with a specific id under the active account.

This supports partial updates so you can send just the properties you wish to update.
 """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_profile_with_id(
    id: str,
    ff: Optional[Ff42] = None,
    lang: Optional[str] = None,
    body: ProfileUpdateRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/request-email-verification',
    description=""" Request that the email address tied to an account be verified.

This will send a verification email to the email address of the primary profile containing
a link which, once clicked, completes the verification process via the /verify-email endpoint.

Note that when an account is created this email is sent automatically so there's no need
to call this directly.

If the user doesn't click the link before it expires then this endpoint can be called
to request a new verification email. In the future it may also be used if we add support
for changing an account email address.
 """,
    tags=['account_management', 'profile_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def request_email_verification(ff: Optional[Ff43] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/authorization',
    description=""" When a user signs out of an application we need to clear some
basic cookies we assigned them during token authorization.
 """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
)
def sign_out(ff: Optional[Ff44] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization',
    description=""" Request one or more `Account` level authorization tokens each with a chosen scope.

Tokens are used to access restricted service endpoints. These restricted endpoints
will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
before access is granted.

For convenience, where a Profile level token with the same scope exists it will also be returned.

Authorization with pin is not supported on this endpoint anymore. Use `/itv/pinauthorization`
endpoint instead.
 """,
    tags=['account_management', 'user_authentication_management'],
)
def get_account_token(
    ff: Optional[Ff45] = None,
    lang: Optional[str] = None,
    body: AccountTokenRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization/device',
    description=""" Get Catalog tokens for an account using a device authorization code.
Where a Profile level token of Catalog scope exists it will also be returned.

This is the final step in the process of authorizing a device by pin code.

Firstly the device must request a generated authorization code via the
`/authorization/device/code` endpoint.

The code is subsequently used to authorize the device to sign in to a given
account via the `/account/devices/authorization` endpoint. Typically this
will be from a page presented in the web app under the account section.

Once authorized, this endpoint will allow the device to sign in without
needing to provide the credentials of the user.
 """,
    tags=['account_management', 'user_authentication_management'],
)
def get_account_token_by_code(
    ff: Optional[Ff46] = None,
    lang: Optional[str] = None,
    body: AccountTokenByCodeRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization/device/code',
    description=""" Get a generated device authorization code.

This is the first step in the process of authorizing a device by pin code.
The device will make a request to this endpoint providing a unique identifier
for the device such as a serial number. This endpoint will then return a
generated code which is tied to the given device.

The code may subsequently be used to authorize the device to sign in to an
account via the `/account/devices/authorization` endpoint. Typically this
will be from a page presented in the web app under the account section.

Once authorized, the device will then be able to sign in to that account
via the `/authorization/device` endpoint, without needing to provide the 
credentials of the user.
 """,
    tags=['device_management'],
)
def generate_device_authorization_code(
    ff: Optional[Ff47] = None,
    lang: Optional[str] = None,
    body: DeviceRegistrationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization/profile',
    description=""" Request one or more `Profile` level authorization tokens each with a chosen scope.

Tokens are used to access restricted service endpoints. These restriced endpoints
will require a specific token type (e.g Profile) with a specific scope (e.g. Catalog)
before access is granted.
 """,
    tags=['user_authentication_management', 'profile_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_profile_token(
    ff: Optional[Ff48] = None,
    lang: Optional[str] = None,
    body: ProfileTokenRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization/refresh',
    description=""" Refresh an account or profile level authorization token which is marked as refreshable. """,
    tags=['user_authentication_management'],
)
def refresh_token(
    ff: Optional[Ff49] = None,
    lang: Optional[str] = None,
    body: TokenRefreshRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/authorization/sso',
    description=""" Exchange a third party single-sign-on token for our own authorization tokens. """,
    tags=['user_authentication_management'],
)
def single_sign_on(
    ff: Optional[Ff50] = None,
    lang: Optional[str] = None,
    body: SingleSignOnRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bt/plan/{token}',
    description=""" Returns all the plans available for BT flow including additional description data. """,
    tags=['user_authentication_management'],
)
def get_plan_by_token(token: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bt/plans',
    description=""" Returns all the plans available for BT flow including additional description data. """,
    tags=['app_configuration_retrieval'],
)
def get_plans(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/bt/token/assign',
    description=""" Assigns an UserToken to a profile on the ITV side. Currently throws an exception. """,
    tags=['account_management', 'user_authentication_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def assign_token(lang: Optional[str] = None, body: ItvAssignBtTokenRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bt/token/validate',
    description=""" Checks a provided token for BT eligible user.
 """,
    tags=['account_management'],
)
def check_user_token(id: str, ff: Optional[Ff51] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/check-subscription/{id}',
    description=""" Returns the details of subscription data for a user with specified id. """,
    tags=['account_management'],
)
def get_subscription_data(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/config',
    description=""" Get the global configuration for an application. Should be called during app statup.

This includes things like device and playback rules, classifications,
sitemap and subscriptions.

You have the option to select specific configuration objects using the 'include'
parameter, or if unspecified, getting all configuration.
 """,
    tags=['device_management', 'app_configuration_retrieval'],
)
def get_app_config(
    include: Optional[Include1] = None,
    system: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff52] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ee-bt/eligibility',
    description=""" Check whether or not a user is eligible for switching to Bt or EE offers. """,
    tags=['user_authentication_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def check_ee_bt_eligibility(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ee/msisdn',
    description=""" Assigns a msisdn to a profile on ITV side. """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def assign_msisdn(lang: Optional[str] = None, body: ItvAssignMsisdnRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ee/offers',
    description=""" Returns eligible partner specific offers for the querying partner for an EE MSISDN.
This call is supposed to be called after we have MSISDN accired.
This call should be followed by POST /ee/msisdn.
 """,
    tags=['app_configuration_retrieval'],
)
def get_eligible_offers(
    ff: Optional[Ff53] = None, lang: Optional[str] = None, body: EeOffersRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ee/pin',
    description=""" Validate PIN request created by calling POST /ee/pin This call is to validate MSISDN entered by a user not comming through EE network. This call should be called after PUT /ee/pin. This call should be followed by POST /ee/offers. """,
    tags=['security_operations', 'pin_operations'],
)
def validate_pin_request(
    ff: Optional[Ff54] = None,
    lang: Optional[str] = None,
    body: EeValidatePinRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ee/pin',
    description=""" Creates a PIN request that will send an SMS to the given msisdn.
This call is to validate MSISDN entered by a user not comming through EE network.
This call should be followed by POST ee/pin.
 """,
    tags=['pin_operations', 'security_operations'],
)
def create_pin_request(
    ff: Optional[Ff55] = None,
    lang: Optional[str] = None,
    body: EeCreatePinRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ee/plans',
    description=""" Returns all the plans available for EE flow including additional description data. """,
    tags=['app_configuration_retrieval'],
)
def get_ee_plans(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ee/plans/{id}',
    description=""" Returns the plan description for EE flow including additional description data. """,
    tags=['user_authentication_management'],
)
def get_plan(id: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ee/token/create',
    description=""" Returns a token for later calls to EE API. TTL is one hour. Recommended is FE refreshes this token before each call. """,
    tags=['account_management', 'user_authentication_management', 'profile_management'],
)
def create_token():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{id}',
    description=""" Returns the details of an item with the specified id. """,
    tags=['entitlement_retrieval', 'item_operations'],
)
def get_item(
    id: str,
    max_rating: Optional[str] = None,
    expand: Optional[Expand2] = None,
    select_season: Optional[SelectSeason] = None,
    use_custom_id: Optional[bool] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff56] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{id}/children',
    description=""" Returns the List of child summary items under an item.

If the item is a Season then the children will be episodes and ordered by episode number.

If the item is a Show then the children will be Seasons and ordered by season number.

Returns 404 if no children found.
 """,
    tags=['entitlement_retrieval', 'item_operations', 'item_list_management'],
)
def get_item_children_list(
    id: str,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=100)] = 12,
    max_rating: Optional[str] = None,
    order: Optional[Order] = 'desc',
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff57] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{id}/related',
    description=""" Returns the list of items related to the parent item.

Note for now, due to the size of the list being unknown, only a single page will be returned.
 """,
    tags=['entitlement_retrieval', 'item_list_management', 'content_search_operations'],
)
def get_item_related_list(
    id: str,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=100)] = 12,
    max_rating: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff58] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{id}/videos',
    description=""" Get the free / public video files associated with an item given maximum resolution,
device type and one or more delivery types.

Returns an array of video file objects which each include a url to a video.

The first entry in the array contains what is predicted to be the best match.
The remainder of the entries, if any, may contain resolutions below what was
requests. For example if you request HD-720 the response may also contain
SD entries.

If you specify multiple delivery types, then the response array will insert
types in the order you specify them in the query. For example `stream,progressive`
would return an array with 0 or more stream files followed by 0 or more progressive files.

If no files are found a 404 is returned.
 """,
    tags=['entitlement_retrieval', 'item_operations'],
)
def get_public_item_media_files(
    id: str,
    delivery: Delivery2 = ...,
    resolution: Resolution4 = ...,
    formats: Optional[Formats2] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff59] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/items/{itemId}/next',
    description=""" Identical to GET /account/profile/items/{itemId}/next route but for users
that are not logged in i.e. this endpoint does not require authorisation
 """,
    tags=['rating_system_management', 'item_operations'],
)
def get_anon_next_playback_item(
    item_id: str = Path(..., alias='itemId'),
    max_rating: Optional[str] = None,
    expand: Optional[Expand4] = None,
    device: Optional[str] = 'web_browser',
    segments: Optional[Segments] = None,
    ff: Optional[Ff60] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/billinghistory/{platform}',
    description=""" Returns the list of billing records for specified payment platform. """,
    tags=['billing_management', 'account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_billing_history(
    platform: str, lang: Optional[str] = None, body: ItvBillingHistoryRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/cards/{platform}',
    description=""" Get payment card details. """,
    tags=['account_management', 'entitlement_retrieval', 'item_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_card_details(
    platform: str, lang: Optional[str] = None, body: ItvGetCardDetailsRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/itv/cards/{platform}',
    description=""" Change payment card details. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def change_card_details(
    platform: str, lang: Optional[str] = None, body: ItvChangeCardDetailsRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/changeemail',
    description=""" Change email address related to account/profile.

The expected token scope is Settings.
 """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def change_email(
    ff: Optional[Ff61] = None,
    lang: Optional[str] = None,
    body: ItvChangeEmailRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/changemarketing',
    description=""" Change marketing preferences related to account/profile.

The expected token scope is Settings.
 """,
    tags=['entitlement_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def change_marketing(
    ff: Optional[Ff62] = None,
    lang: Optional[str] = None,
    body: ItvChangeMarketingRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/deleteaccount',
    description=""" Delete account in compliance with GDPR.

The expected token scope is Settings.
 """,
    tags=['account_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def delete_account(
    ff: Optional[Ff63] = None,
    lang: Optional[str] = None,
    body: ItvDeleteAccountRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/entitlements/current',
    description=""" Returns current entitlement. """,
    tags=['app_configuration_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_current_entitlement(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/entitlements/history',
    description=""" Returns the state of subscription for any payment platform. """,
    tags=['user_authentication_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_entitlements_history(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/featureFlag/{feature}',
    description=""" Gets info whether or not a feature is enabled or disabled using a feature flag. Feature flags are set as a custom field within PM. It also supports custom feature flag data if needed. Such data can be return as well. """,
    tags=['profile_management'],
)
def get_feature_flag(feature: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/googlepay/subscription',
    description=""" Get the list of recommended items under the active profile. """,
    tags=['subscription_management'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def google_pay_subscription(
    lang: Optional[str] = None, body: ItvGooglePaySubscriptionRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/had/entitlements',
    description=""" Check whether the user has been previously entitled. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def check_previous_entitlements(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/items/clips',
    description=""" Get the media clip files associated with items.
 """,
    tags=['item_operations'],
)
def get_items_media_clip_files(
    ff: Optional[Ff64] = None,
    lang: Optional[str] = None,
    body: ItemDownloadableRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/items/downloadable',
    description=""" Returns the details of an item with the specified id. """,
    tags=['item_operations', 'entitlement_retrieval'],
)
def get_item_downloadables(
    ff: Optional[Ff65] = None,
    lang: Optional[str] = None,
    body: ItemDownloadableRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/itemsummary/{externalId}',
    description=""" Redirects to corresponding Axis Item details page. """,
    tags=['user_profile_operations'],
)
def get_itv_itemsummary__external_id(external_id: str = Path(..., alias='externalId')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/page',
    description=""" Returns a page with the specified id.

This is a cut down version for low memory devices.123

If targeting the search page you must url encode the search term as a parameter
using the `q` key. For example if your browser path looks like `/search?q=the`
then what you pass to this endpoint would look like `/itv/page?path=/search%3Fq%3Dthe`.
 """,
    tags=['item_list_management', 'content_search_operations'],
)
def get_itv_page(
    path: str,
    list_page_size: Optional[conint(ge=1, le=100)] = 12,
    list_page_size_large: Optional[conint(ge=1, le=100)] = 50,
    max_list_prefetch: Optional[conint(ge=0, le=15)] = 2,
    item_detail_expand: Optional[ItemDetailExpand] = None,
    item_detail_select_season: Optional[ItemDetailSelectSeason] = None,
    text_entry_format: Optional[TextEntryFormat] = 'markdown',
    max_rating: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff66] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/pinauthorization',
    description=""" Provides authorization with parental control pin.

Returns an array containing account token with Playback scope.

Requires access token with Catalog scope.

Pin must be a 4-digit string
 """,
    tags=['user_authentication_management', 'security_operations', 'pin_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_account_token_with_pin(
    ff: Optional[Ff67] = None, lang: Optional[str] = None, body: ItvPinAuthRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/plan/{platform}',
    description=""" Upgrades the plan for the current user. """,
    tags=['app_configuration_retrieval', 'plan_information_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def upgrade_plan(
    platform: str, lang: Optional[str] = None, body: ItvUpgradePlanRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/plans/{platform}',
    description=""" Returns the plans available for specified payment platform. """,
    tags=['device_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_itv_plans__platform(platform: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/profile',
    description=""" Returns the ITV profile object. """,
    tags=['app_configuration_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_itv_profile(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/itv/profile',
    description=""" Update ITV profile.

The expected token scope is Settings.
 """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_profile(
    ff: Optional[Ff68] = None,
    lang: Optional[str] = None,
    body: ItvUpdateProfileRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/profile/recommendation/list',
    description=""" Get the list of recommended items under the active profile. """,
    tags=['item_operations', 'item_list_management', 'content_search_operations'],
    security=[
        OAuth2PasswordBearer(
            name="None", token_url="/api//account/profile/authorization"
        ),
    ],
)
def get_recommended_list(
    item_types: Optional[ItemTypes] = None,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=50)] = 12,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff69] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/profiletoken',
    description=""" Returns the ITV profile token. """,
    tags=[
        'user_authentication_management',
        'profile_management',
        'user_profile_operations',
    ],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_itv_profile_token(
    lang: Optional[str] = None, body: ItvProfileTokenRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/itv/purchase/{platform}',
    description=""" Cancel a plan subscription.

A cancelled subscription will continue to be valid until the subscription
expiry date or next renewal date.
 """,
    tags=['subscription_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def delete_itv_purchase__platform(
    platform: str, lang: Optional[str] = None, body: ItvCancelSubscriptionRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/purchase/{platform}',
    description=""" Returns the details of current subscription for specified payment platform. """,
    tags=['user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_current_subscription(platform: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/purchase/{platform}',
    description=""" Confirms purchase and returns the details of purchased subscription for specified payment platform. """,
    tags=['purchase_management', 'payment_transaction_processing'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def confirm_purchase(
    platform: str, lang: Optional[str] = None, body: ItvPurchaseRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/purchase/{platform}/strong',
    description=""" Confirms purchase and returns the details of purchased subscription for specified payment platform. """,
    tags=['purchase_management', 'payment_transaction_processing'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def confirm_purchase_strong(
    platform: str, lang: Optional[str] = None, body: ItvPurchaseStrongRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/purchase/{platform}/withoffer',
    description=""" Confirms purchase and returns the details of purchased subscription for specified payment platform. """,
    tags=['purchase_management', 'payment_transaction_processing'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def confirm_purchase_with_offer(
    platform: str, lang: Optional[str] = None, body: ItvPurchaseWithOfferRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/resubscribe/{platform}',
    description=""" Resubscription for a user. """,
    tags=['plan_information_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def resubscribe(
    plan_id: str = Query(..., alias='planId'),
    platform: str = ...,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/roku/plans',
    description=""" Gets available Roku plans. """,
    tags=['app_configuration_retrieval'],
)
def get_itv_roku_plans(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/roku/transaction/{transactionid}',
    description=""" Sends request to execute specified transaction. """,
    tags=['purchase_management', 'payment_transaction_processing'],
)
def execute_transaction(
    transactionid: str,
    lang: Optional[str] = None,
    body: ItvRokuTransactionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/save-offer',
    description=""" Checks the provided coupon id for a user. Only Stripe platform is currently supported. """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_save_offer(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/save-offer',
    description=""" Activates the discount for a user. Only Stripe platform is currently supported. """,
    tags=['user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def activate_save_offer(lang: Optional[str] = None, body: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/subscription/fullpricerenewal',
    description=""" Returns full price renewal state and reason for specific user. """,
    tags=['profile_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_full_price_renewal(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/subscription/status/{platform}',
    description=""" Returns status of latest payment intent. """,
    tags=['app_configuration_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_subscription_status(platform: str, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/subscriptionstate',
    description=""" Returns the state of subscription for any payment platform. """,
    tags=['app_configuration_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_subscription_state(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/upcominginvoice',
    description=""" Returns an upcoming invoice """,
    tags=['app_configuration_retrieval'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_upcoming_invoice(lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/itv/updateIntent/strong/{platform}',
    description=""" Change payment method details. """,
    tags=['account_management', 'user_profile_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_payment_intent_strong(
    platform: str, lang: Optional[str] = None, body: ItvUpdateIntentStrongRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/itv/updatePayment/strong/{platform}',
    description=""" Change payment method details. """,
    tags=[
        'payment_transaction_processing',
        'billing_management',
        'subscription_management',
    ],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def update_payment_method_strong(
    platform: str, lang: Optional[str] = None, body: ItvUpdatePaymentStrongRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/itv/voucher/{planId}/{voucherId}',
    description=""" Checks the provided coupon id for a user. Only Stripe platform is currently supported. """,
    tags=['voucher_operations', 'subscription_management'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def get_voucher_by_id(
    voucher_id: str = Path(..., alias='voucherId'),
    plan_id: str = Path(..., alias='planId'),
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/itv/voucher/{platform}',
    description=""" Validates the coupon/voucher for specified payment platform. """,
    tags=['voucher_operations'],
    security=[
        OAuth2PasswordBearer(name="None", token_url="/api//account/authorization"),
    ],
)
def check_voucher(
    platform: str, lang: Optional[str] = None, body: ItvVoucherRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lists',
    description=""" Returns an array of item lists with their first page of content resolved. """,
    tags=['entitlement_retrieval', 'item_operations', 'item_list_management'],
)
def get_lists(
    ids: Ids,
    page_size: Optional[conint(ge=1, le=100)] = 12,
    max_rating: Optional[str] = None,
    order: Optional[Order] = 'desc',
    order_by: Optional[OrderBy5] = None,
    item_type: Optional[ItemType] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff70] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lists/{id}',
    description=""" Returns a list of items under the specified item list """,
    tags=['item_operations', 'content_search_operations'],
)
def get_list(
    id: str,
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=1, le=100)] = 12,
    max_rating: Optional[str] = None,
    order: Optional[Order] = 'desc',
    order_by: Optional[OrderBy5] = None,
    param: Optional[str] = None,
    item_type: Optional[ItemType] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff71] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/page',
    description=""" Returns a page with the specified id.

If targeting the search page you must url encode the search term as a parameter
using the `q` key. For example if your browser path looks like `/search?q=the`
then what you pass to this endpoint would look like `/page?path=/search%3Fq%3Dthe`.
 """,
    tags=['item_list_management', 'content_search_operations'],
)
def get_page(
    path: str,
    list_page_size: Optional[conint(ge=1, le=100)] = 12,
    list_page_size_large: Optional[conint(ge=1, le=100)] = 50,
    max_list_prefetch: Optional[conint(ge=0, le=15)] = 2,
    item_detail_expand: Optional[ItemDetailExpand] = None,
    item_detail_select_season: Optional[ItemDetailSelectSeason] = None,
    text_entry_format: Optional[TextEntryFormat] = 'markdown',
    max_rating: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff72] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/plans/{id}',
    description=""" Returns the details of a Plan with the specified id. """,
    tags=['device_management'],
)
def get_plans__id(
    id: str,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff73] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/register',
    description=""" Register a new user, creating them an account.

Registration, when successful, will return an array of access tokens so the user is
immediately signed in.

It returns Catalog and Commerce scoped tokens for both Account and Profile.
The Commerce ones are intended to allow the purchase of a subscription plan
in the step after registration, without the user being prompted to enter
their username and password again.

An email will also be sent with a link they need to click to confirm their
email address. This confirmation is done via the /verify-email endpoint.
 """,
    tags=['user_authentication_management'],
)
def register(
    ff: Optional[Ff74] = None,
    lang: Optional[str] = None,
    body: RegistrationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/request-password-reset',
    description=""" Request the password of an account's primary profile be reset.

Should be called when a user has forgotten their password.

This will send an email with a password reset link to the email address of the
primary profile of an account.

The link, once clicked, should take the user to the "reset-password" page of the
website. Here they will enter their new password and submit to the /reset-password
endpoint here, along with the password reset token provided in the original link.
 """,
    tags=['user_authentication_management', 'security_operations'],
)
def forgot_password(
    ff: Optional[Ff75] = None,
    lang: Optional[str] = None,
    body: PasswordResetEmailRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reset-password',
    description=""" When a user requests to reset their password via the /request-password-reset endpoint, an
email is sent to the email address of the primary profile of the account. This email contains a link
with a reset token as query parameter. The link should take the user to the "reset-password"
page of the website.

From the reset-password page a user should enter the new password they wish to use. 
It should then be submitted to this endpoint,
along with the reset token from the email link. 
The token should be provided in the body as resetToken property.
 """,
    tags=['user_authentication_management', 'security_operations'],
)
def reset_password(
    ff: Optional[Ff76] = None,
    lang: Optional[str] = None,
    body: PasswordResetRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/samsung-preview',
    description=""" Returns public preview for Samsung based on the page '/samsung-preview' configured in PresentationManager.
There is a hard limit of max 40 items to be returned. It splits evenly items count into the page rows, remaining items are added into the first row.
 """,
    tags=['None'],
)
def get_public_preview():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/schedules',
    description=""" Returns schedules for a defined set of channels over a requested period.

Schedules are requested in hour blocks and returned grouped by the channel
they belong to.

For example, to load 12 hours of schedules for channels `4343` and `5234`,
on 21/2/2017 starting from 08:00.

```
channels=4343,5234
date=2017-02-21
hour=8
duration=12
```

Please remember that `date` and `hour` combined represent a normal datetime, 
so they should be converted to UTC on the client - this will help to avoid 
issues with EPG schedules near midnight.

If a channel id is passed which doesn't exist then this endpoint will
return an empty schedule list for it. If instead we returned 404,
this would invalidate all other channel schedules in the same request
which would be unfriendly for clients presenting these channel schedules.
 """,
    tags=['schedules_management'],
)
def get_schedules(
    channels: Channels,
    date: date = ...,
    hour: conint(ge=0, le=23) = ...,
    duration: conint(ge=-24, le=24) = ...,
    intersect: Optional[bool] = False,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff77] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search',
    description=""" Search the catalog of items and people. """,
    tags=['content_search_operations'],
)
def search(
    term: str,
    include: Optional[Include2] = None,
    group: Optional[bool] = None,
    max_results: Optional[conint(ge=1, le=50)] = 20,
    max_rating: Optional[str] = None,
    device: Optional[str] = 'web_browser',
    sub: Optional[str] = None,
    segments: Optional[Segments] = None,
    ff: Optional[Ff78] = None,
    lang: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/verify-email',
    description=""" When an account is created an email is sent to the email address of the new account.
This contains a link, which once clicked, verifies the email address of the account is correct.

The link contains a token as a query parameter which should be passed as the authorization
bearer token to this endpoint to complete email verification.

The token has en expiry, so if the link is not clicked before it expires, the account holder
may need to request a new verification email be sent. This can be done via the endpoint
/account/request-email-verification.
 """,
    tags=['account_management', 'profile_management', 'user_profile_operations'],
    security=[
        APIKeyHeader(name="authorization"),
    ],
)
def verify_email(ff: Optional[Ff79] = None, lang: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
